#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$repo_root" ]]; then
  echo "ERROR: not inside a git repository."
  exit 1
fi
cd "$repo_root"

QF_RETRY_MAX="${QF_RETRY_MAX:-3}"
QF_RETRY_BASE_SEC="${QF_RETRY_BASE_SEC:-1}"
RETRY_OUTPUT=""
RETRY_LAST_ERROR=""

usage() {
  cat <<'EOF'
Usage:
  tools/qf init
  tools/qf onboard RUN_ID
  tools/qf ready RUN_ID=<run-id>
  tools/qf snapshot RUN_ID=<run-id> NOTE=<text>
  tools/qf handoff RUN_ID=<run-id>
  tools/qf plan [N]
  tools/qf do queue-next
  tools/qf resume RUN_ID=<run-id>
EOF
}

is_dirty() {
  if ! git diff --quiet || ! git diff --cached --quiet || [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
    return 0
  fi
  return 1
}

print_resume_cmd() {
  local run_id="$1"
  if [[ -n "$run_id" ]]; then
    echo "恢复命令：tools/qf resume RUN_ID=${run_id}"
  fi
}

json_escape() {
  local value="${1:-}"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/}"
  printf "%s" "$value"
}

redact_text() {
  local value="${1:-}"
  if [[ "${QF_LOG_REDACT:-1}" != "1" ]]; then
    printf "%s" "$value"
    return 0
  fi
  printf "%s" "$value" | sed -E \
    -e 's/(token|password|passwd|secret|api[_-]?key)[[:space:]]*=[[:space:]]*[^[:space:]]+/\1=<redacted>/Ig' \
    -e 's/(Authorization:[[:space:]]*Bearer)[[:space:]]+[A-Za-z0-9._-]+/\1 <redacted>/Ig' \
    -e 's/\b(ghp_[A-Za-z0-9]+)\b/<redacted>/g' \
    -e 's/\b(sk-[A-Za-z0-9]+)\b/<redacted>/g'
}

append_execution_event() {
  local run_id="$1"
  local phase="$2"
  local action="$3"
  local status="$4"
  local command="${5:-}"
  local artifacts="${6:-}"
  local error="${7:-}"
  local file=""
  local command_r=""
  local artifacts_r=""
  local error_r=""
  local max_len="${QF_LOG_MAX_LEN:-200}"

  if [[ -z "$run_id" || "${QF_LOG_DISABLE:-0}" == "1" ]]; then
    return 0
  fi

  command_r="$(redact_text "$command")"
  artifacts_r="$(redact_text "$artifacts")"
  error_r="$(redact_text "$error")"
  if [[ "${#command_r}" -gt "$max_len" ]]; then
    command_r="${command_r:0:${max_len}}...(truncated)"
  fi
  if [[ "${#artifacts_r}" -gt "$max_len" ]]; then
    artifacts_r="${artifacts_r:0:${max_len}}...(truncated)"
  fi
  if [[ "${#error_r}" -gt "$max_len" ]]; then
    error_r="${error_r:0:${max_len}}...(truncated)"
  fi

  file="reports/${run_id}/execution.jsonl"
  mkdir -p "reports/${run_id}"
  printf '{"ts":"%s","run_id":"%s","phase":"%s","action":"%s","status":"%s","command":"%s","artifacts":"%s","error":"%s"}\n' \
    "$(date -Iseconds)" \
    "$(json_escape "$run_id")" \
    "$(json_escape "$phase")" \
    "$(json_escape "$action")" \
    "$(json_escape "$status")" \
    "$(json_escape "$command_r")" \
    "$(json_escape "$artifacts_r")" \
    "$(json_escape "$error_r")" >> "$file"
}

run_with_retry_capture() {
  local step="$1"
  shift
  local attempt=1
  local delay="$QF_RETRY_BASE_SEC"
  local rc=0
  local output=""

  RETRY_OUTPUT=""
  RETRY_LAST_ERROR=""
  while true; do
    set +e
    output="$("$@" 2>&1)"
    rc=$?
    set -e
    if [[ "$rc" -eq 0 ]]; then
      RETRY_OUTPUT="$output"
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output"
      fi
      return 0
    fi

    RETRY_LAST_ERROR="$(printf "%s" "$output" | tail -n 3 | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//')"
    if [[ "$attempt" -ge "$QF_RETRY_MAX" ]]; then
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output" >&2
      fi
      return "$rc"
    fi
    echo "retry[$attempt/$QF_RETRY_MAX] step=$step rc=$rc: ${RETRY_LAST_ERROR:-unknown}" >&2
    sleep "$delay"
    attempt=$((attempt + 1))
    delay=$((delay * 2))
  done
}

auto_stash_if_dirty() {
  local prefix="$1"
  if ! is_dirty; then
    return 0
  fi
  if [[ "${QF_AUTOSTASH:-1}" != "1" ]]; then
    echo "❌ 工作区不干净（有未提交改动）"
    echo "   修复：先处理未提交改动，或设置 QF_AUTOSTASH=1 后重试。"
    return 1
  fi
  local stash_name="qf-${prefix}-wip-$(date +%Y%m%d-%H%M%S)"
  echo "Detected local changes. Stashing as: ${stash_name}"
  git stash push -u -m "$stash_name" >/dev/null
  local latest_stash
  latest_stash="$(git stash list -1 | head -n1 || true)"
  echo "stashed: ${latest_stash:-$stash_name}"
  echo "恢复指令："
  echo "  git stash list"
  echo "  git stash pop stash@{0}"
}

cmd_onboard() {
  local run_id="${1:-${RUN_ID:-}}"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: RUN_ID is required. Usage: tools/qf onboard <RUN_ID>" >&2
    exit 2
  fi

  local repo_root reports_dir out_dir out_file state_file queue_file decisions_glob recent_limit tmp_recent
  repo_root="${ONBOARD_REPO_ROOT:-.}"
  reports_dir="${ONBOARD_REPORTS_DIR:-${repo_root}/reports}"
  out_dir="${ONBOARD_OUT_DIR:-${reports_dir}/${run_id}}"
  out_file="${out_dir}/onboard.md"
  state_file="${ONBOARD_STATE_FILE:-${repo_root}/TASKS/STATE.md}"
  queue_file="${ONBOARD_QUEUE_FILE:-${repo_root}/TASKS/QUEUE.md}"
  decisions_glob="${ONBOARD_DECISIONS_GLOB:-${reports_dir}/run-*/decision.md}"
  recent_limit="${ONBOARD_RECENT_LIMIT:-8}"

  mkdir -p "$out_dir"
  tmp_recent="$(mktemp)"
  trap 'rm -f "${tmp_recent:-}"' RETURN

  # shellcheck disable=SC2086
  ls -1t ${decisions_glob} 2>/dev/null | head -n "${recent_limit}" > "$tmp_recent" || true

  {
    echo "# Session Onboard"
    echo
    echo "RUN_ID: \`${run_id}\`"
    echo "Generated At: $(date -Iseconds)"
    echo
    echo "## 宪法/硬规则入口"
    echo "- AGENTS.md"
    echo
    echo "## 项目背景/阶段入口"
    echo "- PROJECT_GUIDE.md"
    echo
    echo "## 工作流入口"
    echo "- docs/WORKFLOW.md"
    echo "- TASKS/STATE.md"
    echo "- TASKS/QUEUE.md"
    echo
    echo "## 强制复述模板入口"
    echo "- PROJECT_GUIDE.md#强制复述模板"
    echo
    echo "## 最近 decision 入口列表"
    if [[ -s "$tmp_recent" ]]; then
      while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        rel="${item#${repo_root}/}"
        echo "- ${rel}"
      done < "$tmp_recent"
    else
      echo "- 无（未检出 reports/run-*/decision.md）"
    fi
    echo
    echo "## 快速检查"
    if [[ -f "$state_file" ]]; then
      echo "- STATE: ${state_file#${repo_root}/}"
    else
      echo "- STATE: missing (${state_file})"
    fi
    if [[ -f "$queue_file" ]]; then
      echo "- QUEUE: ${queue_file#${repo_root}/}"
    else
      echo "- QUEUE: missing (${queue_file})"
    fi
  } | tee "$out_file"

  echo "ONBOARD_FILE: $out_file"
}

read_or_prompt_field() {
  local env_key="$1"
  local prompt="$2"
  local value="${!env_key:-}"
  if [[ -n "$value" ]]; then
    printf "%s" "$value"
    return 0
  fi
  if [[ -t 0 ]]; then
    echo -n "$prompt"
    IFS= read -r value
    printf "%s" "$value"
    return 0
  fi
  echo "ERROR: missing $env_key and no interactive stdin for prompt: $prompt" >&2
  return 1
}

cmd_ready() {
  local arg="${1:-}"
  local run_id=""
  local goal scope acceptance steps stop
  local ready_file=""
  local py_bin=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    run_id="${arg#RUN_ID=}"
  elif [[ -n "$arg" ]]; then
    run_id="$arg"
  elif [[ -n "${RUN_ID:-}" ]]; then
    run_id="${RUN_ID}"
  fi

  if [[ -z "$run_id" ]]; then
    echo "ERROR: ready requires RUN_ID. Usage: tools/qf ready RUN_ID=<run-id>" >&2
    exit 2
  fi

  goal="$(read_or_prompt_field "QF_READY_GOAL" "Goal (one sentence): ")" || exit 1
  scope="$(read_or_prompt_field "QF_READY_SCOPE" "Scope (exact paths): ")" || exit 1
  acceptance="$(read_or_prompt_field "QF_READY_ACCEPTANCE" "Acceptance (verify/evidence/scope): ")" || exit 1
  steps="$(read_or_prompt_field "QF_READY_STEPS" "Execution steps: ")" || exit 1
  stop="$(read_or_prompt_field "QF_READY_STOP" "Stop condition: ")" || exit 1

  if [[ -z "$goal" || -z "$scope" || -z "$acceptance" || -z "$steps" || -z "$stop" ]]; then
    echo "ERROR: ready fields cannot be empty." >&2
    exit 1
  fi

  mkdir -p "reports/${run_id}"
  ready_file="reports/${run_id}/ready.json"

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required to write ready.json" >&2
    exit 1
  fi

  "$py_bin" - <<'PY' "$ready_file" "$run_id" "$goal" "$scope" "$acceptance" "$steps" "$stop"
import json
import sys
from datetime import datetime, timezone

out, run_id, goal, scope, acceptance, steps, stop = sys.argv[1:]
obj = {
    "run_id": run_id,
    "created_at_utc": datetime.now(timezone.utc).isoformat(),
    "constitution_read": True,
    "workflow_read": True,
    "restatement_passed": True,
    "restatement": {
        "goal": goal,
        "scope": scope,
        "acceptance": acceptance,
        "steps": steps,
        "stop_condition": stop,
    },
}
with open(out, "w", encoding="utf-8") as f:
    json.dump(obj, f, ensure_ascii=False, indent=2)
    f.write("\n")
PY

  append_execution_event "$run_id" "ready" "ready_passed" "ok" "tools/qf ready" "ready_file=${ready_file}" ""
  echo "READY_FILE: $ready_file"
  echo "READY_RUN_ID: $run_id"
}

cmd_snapshot() {
  local run_id="${RUN_ID:-}"
  local note="${QF_SNAPSHOT_NOTE:-}"
  local arg=""
  local ready_file=""
  local snapshot_file=""
  local now_iso=""
  local branch=""
  local head=""
  local status_line=""

  for arg in "$@"; do
    case "$arg" in
      RUN_ID=*)
        run_id="${arg#RUN_ID=}"
        ;;
      NOTE=*)
        note="${arg#NOTE=}"
        ;;
      *)
        if [[ -z "$run_id" ]]; then
          run_id="$arg"
        elif [[ -z "$note" ]]; then
          note="$arg"
        fi
        ;;
    esac
  done

  if [[ -z "$run_id" ]]; then
    ready_file="$(resolve_ready_file || true)"
    if [[ -n "$ready_file" ]]; then
      run_id="$(basename "$(dirname "$ready_file")")"
    fi
  fi
  if [[ -z "$run_id" ]]; then
    echo "ERROR: snapshot requires RUN_ID=<run-id> (or an existing ready marker)." >&2
    exit 2
  fi

  mkdir -p "reports/${run_id}"
  snapshot_file="reports/${run_id}/conversation.md"
  now_iso="$(date -Iseconds)"
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")"
  head="$(git rev-parse --short HEAD 2>/dev/null || echo "none")"
  if is_dirty; then
    status_line="dirty"
  else
    status_line="clean"
  fi

  {
    echo "## ${now_iso}"
    echo "- branch: \`${branch}\`"
    echo "- head: \`${head}\`"
    echo "- working_tree: \`${status_line}\`"
    if [[ -n "$note" ]]; then
      echo "- note: ${note}"
    else
      echo "- note: (empty)"
    fi
    echo
  } >> "$snapshot_file"

  echo "SNAPSHOT_FILE: $snapshot_file"
  echo "SNAPSHOT_RUN_ID: $run_id"
}

cmd_handoff() {
  local arg="${1:-}"
  local run_id=""
  local ready_file=""
  local convo_file=""
  local exec_file=""
  local ship_file=""
  local out_file=""
  local py_bin=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    run_id="${arg#RUN_ID=}"
  elif [[ -n "$arg" ]]; then
    run_id="$arg"
  elif [[ -n "${RUN_ID:-}" ]]; then
    run_id="${RUN_ID}"
  fi

  if [[ -z "$run_id" ]]; then
    ready_file="$(resolve_ready_file || true)"
    if [[ -n "$ready_file" ]]; then
      run_id="$(basename "$(dirname "$ready_file")")"
    fi
  fi
  if [[ -z "$run_id" ]]; then
    echo "ERROR: handoff requires RUN_ID=<run-id> (or an existing ready marker)." >&2
    exit 2
  fi

  ready_file="reports/${run_id}/ready.json"
  convo_file="reports/${run_id}/conversation.md"
  exec_file="reports/${run_id}/execution.jsonl"
  ship_file="reports/${run_id}/ship_state.json"
  out_file="reports/${run_id}/handoff.md"
  mkdir -p "reports/${run_id}"

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required to generate handoff.md" >&2
    exit 1
  fi

  "$py_bin" - <<'PY' "$run_id" "$ready_file" "$convo_file" "$exec_file" "$ship_file" "$out_file"
import json
import os
import sys
from datetime import datetime, timezone

run_id, ready_file, convo_file, exec_file, ship_file, out_file = sys.argv[1:]

def tail_lines(path: str, n: int) -> list[str]:
    if not os.path.exists(path):
        return []
    with open(path, "r", encoding="utf-8") as f:
        lines = f.readlines()
    return [x.rstrip("\n") for x in lines[-n:]]

def read_ready(path: str) -> dict:
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def read_ship(path: str) -> dict:
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def read_exec_tail(path: str, n: int) -> list[dict]:
    if not os.path.exists(path):
        return []
    items = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except Exception:
                continue
    return items[-n:]

ready = read_ready(ready_file)
ship = read_ship(ship_file)
exec_tail = read_exec_tail(exec_file, 8)
convo_tail = tail_lines(convo_file, 20)

missing = []
for p in (ready_file, convo_file, exec_file, ship_file):
    if not os.path.exists(p):
        missing.append(p)

lines = []
lines.append("# Session Handoff")
lines.append("")
lines.append(f"RUN_ID: `{run_id}`")
lines.append(f"Generated At: {datetime.now(timezone.utc).isoformat()}")
lines.append("")
lines.append("## Ready Restatement")
if ready:
    rst = ready.get("restatement", {})
    lines.append(f"- goal: {rst.get('goal', '(missing)')}")
    lines.append(f"- scope: {rst.get('scope', '(missing)')}")
    lines.append(f"- acceptance: {rst.get('acceptance', '(missing)')}")
    lines.append(f"- steps: {rst.get('steps', '(missing)')}")
    lines.append(f"- stop_condition: {rst.get('stop_condition', '(missing)')}")
else:
    lines.append("- missing: ready.json")
lines.append("")
lines.append("## Recent Conversation Checkpoints")
if convo_tail:
    lines.extend(convo_tail)
else:
    lines.append("- missing: conversation.md")
lines.append("")
lines.append("## Recent Execution Events")
if exec_tail:
    for item in exec_tail:
        ts = item.get("ts", "")
        phase = item.get("phase", "")
        action = item.get("action", "")
        status = item.get("status", "")
        artifacts = item.get("artifacts", "")
        lines.append(f"- {ts} | {phase}/{action} | {status} | {artifacts}")
else:
    lines.append("- missing: execution.jsonl")
lines.append("")
lines.append("## Ship State")
if ship:
    lines.append(f"- step: {ship.get('step', '(missing)')}")
    lines.append(f"- pr_url: {ship.get('pr_url', '(none)')}")
    lines.append(f"- branch: {ship.get('branch', '(missing)')}")
    lines.append(f"- last_error: {ship.get('last_error', '(none)')}")
else:
    lines.append("- missing: ship_state.json")
lines.append("")
lines.append("## Missing Inputs")
if missing:
    for p in missing:
        lines.append(f"- {p}")
else:
    lines.append("- none")
lines.append("")
lines.append("## Suggested Next Commands")
lines.append(f"- tools/qf ready RUN_ID={run_id}")
lines.append(f"- tools/qf plan 20")
lines.append(f"- tools/qf do queue-next")
lines.append(f"- tools/qf resume RUN_ID={run_id}")

with open(out_file, "w", encoding="utf-8") as f:
    f.write("\n".join(lines) + "\n")
PY

  append_execution_event "$run_id" "handoff" "handoff_generated" "ok" "tools/qf handoff RUN_ID=${run_id}" "handoff_file=${out_file}" ""
  echo "HANDOFF_FILE: $out_file"
  echo "HANDOFF_RUN_ID: $run_id"
}

ready_file_is_valid() {
  local ready_file="$1"
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    return 1
  fi
  "$py_bin" - <<'PY' "$ready_file"
import json
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        obj = json.load(f)
except Exception:
    raise SystemExit(1)
if not obj.get("restatement_passed"):
    raise SystemExit(1)
print(path)
PY
}

resolve_ready_file() {
  local ready_file=""
  if [[ -n "${QF_READY_RUN_ID:-}" ]]; then
    ready_file="reports/${QF_READY_RUN_ID}/ready.json"
    if [[ -f "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
      printf "%s" "$ready_file"
      return 0
    fi
    printf ""
    return 1
  fi

  ready_file="$(ls -1t reports/run-*/ready.json 2>/dev/null | head -n1 || true)"
  if [[ -n "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
    printf "%s" "$ready_file"
    return 0
  fi

  printf ""
  return 1
}

require_ready_gate() {
  local ready_file=""
  ready_file="$(resolve_ready_file || true)"
  if [[ -z "$ready_file" ]]; then
    echo "ERROR: readiness gate not satisfied." >&2
    echo "Run: tools/qf ready RUN_ID=<run-id>" >&2
    echo "Then retry: tools/qf do queue-next" >&2
    exit 1
  fi
  echo "READY_FILE: $ready_file"
}

sync_main() {
  local run_id="$1"
  if [[ "${QF_SKIP_SYNC:-0}" == "1" ]]; then
    echo "sync skipped (QF_SKIP_SYNC=1)"
    return 0
  fi
  if ! run_with_retry_capture "sync_checkout_main" git checkout main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
  if ! run_with_retry_capture "sync_pull_main" git pull --rebase origin main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
}

cleanup_pick_candidate_dirs() {
  if [[ ! -d "reports" ]]; then
    return 0
  fi
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    rm -rf "$dir"
    echo "CLEANED: $dir"
  done < <(find reports -maxdepth 1 -type d -name 'run-*-pick-candidate' | sort)
}

cmd_init() {
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-init}"
  local knowledge_file="docs/CHANGELOG_KNOWLEDGE.md"
  local knowledge_ttl_days="${QF_KNOWLEDGE_TTL_DAYS:-14}"
  local last_review=""
  local now_epoch=""
  local reviewed_epoch=""
  local age_days=""
  local latest_handoff_run=""
  local py_bin=""
  cleanup_pick_candidate_dirs
  auto_stash_if_dirty "init"
  sync_main "$run_id"
  bash tools/doctor.sh
  cmd_onboard "$run_id"
  if [[ -f "$knowledge_file" ]]; then
    last_review="$(awk '/^- Date: `/ { gsub(/^- Date: `/, "", $0); gsub(/`$/, "", $0); print; exit }' "$knowledge_file" || true)"
    if [[ -n "$last_review" ]]; then
      now_epoch="$(date +%s)"
      reviewed_epoch="$(date -d "$last_review" +%s 2>/dev/null || true)"
      if [[ -n "$reviewed_epoch" ]]; then
        age_days="$(( (now_epoch - reviewed_epoch) / 86400 ))"
        if [[ "$age_days" -gt "$knowledge_ttl_days" ]]; then
          echo "⚠️ Knowledge TTL exceeded: last review ${last_review} (${age_days}d > ${knowledge_ttl_days}d)."
          echo "   建议先执行 knowledge-sync 任务再继续开发。"
        else
          echo "Knowledge review age: ${age_days}d (ttl=${knowledge_ttl_days}d)"
        fi
      fi
    fi
  else
    echo "⚠️ Missing ${knowledge_file}; recommend creating weekly knowledge-sync task."
  fi

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  fi
  if [[ -n "$py_bin" ]]; then
    latest_handoff_run="$("$py_bin" - <<'PY'
from pathlib import Path
root = Path("reports")
if not root.exists():
    raise SystemExit(0)
cands = []
for d in root.glob("run-*"):
    if not d.is_dir():
        continue
    hits = [d / "execution.jsonl", d / "conversation.md", d / "ship_state.json"]
    mt = 0.0
    ok = False
    for p in hits:
        if p.exists():
            ok = True
            mt = max(mt, p.stat().st_mtime)
    if ok:
        cands.append((mt, d.name))
if cands:
    cands.sort(reverse=True)
    print(cands[0][1])
PY
)"
  fi

  echo "INIT_RUN_ID: $run_id"
  append_execution_event "$run_id" "init" "init_completed" "ok" "tools/qf init" "onboard_file=reports/${run_id}/onboard.md" ""
  echo "== 下一步建议 =="
  if [[ -n "$latest_handoff_run" ]]; then
    echo "0) tools/qf handoff RUN_ID=${latest_handoff_run}"
  fi
  echo "1) tools/qf plan 20"
  echo "2) tools/qf ready RUN_ID=$run_id"
  echo "3) tools/qf do queue-next"
}

cmd_plan() {
  local n="${1:-20}"
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-plan}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local proposal_copy="${QF_PLAN_COPY_PATH:-/tmp/qf_todo_proposal.md}"

  sync_main "$run_id"
  bash tools/task.sh --plan "$n"

  if [[ -f "$proposal_file" ]]; then
    cp "$proposal_file" "$proposal_copy"
    echo "PROPOSAL_COPY: $proposal_copy"
  else
    echo "ERROR: proposal file missing: $proposal_file"
    exit 1
  fi

  if [[ -f "TASKS/TODO_PROPOSAL.md" ]]; then
    git restore TASKS/TODO_PROPOSAL.md || true
  fi
  cleanup_pick_candidate_dirs

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "ERROR: qf plan polluted working tree."
    git status --porcelain
    exit 1
  fi
}

cmd_do() {
  local target="${1:-}"
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-do}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local output=""
  local task_file=""
  local task_run_id=""
  local evidence_path=""
  local ready_file=""

  if [[ "$target" != "queue-next" ]]; then
    echo "ERROR: only 'queue-next' is supported."
    usage
    exit 2
  fi

  cleanup_pick_candidate_dirs
  require_ready_gate
  ready_file="$(resolve_ready_file || true)"
  if [[ -n "$ready_file" ]]; then
    run_id="$(basename "$(dirname "$ready_file")")"
  fi
  auto_stash_if_dirty "do"
  append_execution_event "$run_id" "do" "do_start" "ok" "tools/qf do queue-next" "" ""
  sync_main "$run_id"

  if [[ ! -f "$proposal_file" ]]; then
    echo "proposal missing; generating with tools/qf plan 20"
    append_execution_event "$run_id" "do" "do_autoplan" "ok" "tools/qf plan 20" "" ""
    cmd_plan "20"
  fi

  set +e
  output="$(bash tools/task.sh --pick queue-next 2>&1)"
  rc=$?
  set -e
  if [[ "$rc" -ne 0 ]]; then
    printf "%s\n" "$output" >&2
    append_execution_event "$run_id" "do" "do_pick_failed" "fail" "bash tools/task.sh --pick queue-next" "" "$output"
    print_resume_cmd "$run_id"
    exit "$rc"
  fi
  printf "%s\n" "$output"

  task_file="$(printf "%s\n" "$output" | awk -F': ' '/^TASK_FILE:/ {print $2; exit}')"
  task_run_id="$(printf "%s\n" "$output" | awk -F': ' '/^RUN_ID:/ {print $2; exit}')"
  evidence_path="$(printf "%s\n" "$output" | awk -F': ' '/^EVIDENCE_PATH:/ {print $2; exit}')"
  if [[ -n "$task_file" ]]; then
    echo "TASK_FILE: $task_file"
  fi
  if [[ -n "$task_run_id" ]]; then
    echo "RUN_ID: $task_run_id"
  fi
  if [[ -n "$evidence_path" ]]; then
    echo "EVIDENCE_PATH: $evidence_path"
  fi
  if [[ -n "$task_run_id" ]]; then
    append_execution_event "$task_run_id" "do" "do_pick_success" "ok" "bash tools/task.sh --pick queue-next" "task_file=${task_file};evidence=${evidence_path}" ""
  else
    append_execution_event "$run_id" "do" "do_pick_success" "ok" "bash tools/task.sh --pick queue-next" "task_file=${task_file};evidence=${evidence_path}" ""
  fi
}

read_state_field() {
  local file="$1"
  local key="$2"
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required for parsing ship_state.json" >&2
    exit 1
  fi
  "$py_bin" - <<'PY' "$file" "$key"
import json
import sys
path, key = sys.argv[1], sys.argv[2]
with open(path, "r", encoding="utf-8") as f:
    obj = json.load(f)
val = obj.get(key, "")
if val is None:
    val = ""
print(str(val))
PY
}

cmd_resume() {
  local arg="${1:-}"
  local run_id=""
  local state_file=""
  local step=""
  local branch=""
  local pr_url=""
  local msg=""
  local pr_body=""
  local state=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    run_id="${arg#RUN_ID=}"
  fi
  if [[ -z "$run_id" ]]; then
    echo "ERROR: resume requires RUN_ID=..."
    usage
    exit 2
  fi

  state_file="reports/${run_id}/ship_state.json"
  if [[ ! -f "$state_file" ]]; then
    append_execution_event "$run_id" "resume" "resume_missing_state" "fail" "tools/qf resume RUN_ID=${run_id}" "state_file=${state_file}" "missing state file"
    echo "ERROR: missing state file: $state_file"
    print_resume_cmd "$run_id"
    exit 1
  fi

  append_execution_event "$run_id" "resume" "resume_start" "ok" "tools/qf resume RUN_ID=${run_id}" "state_file=${state_file}" ""

  step="$(read_state_field "$state_file" "step")"
  branch="$(read_state_field "$state_file" "branch")"
  pr_url="$(read_state_field "$state_file" "pr_url")"
  msg="$(read_state_field "$state_file" "msg")"
  if [[ -z "$msg" ]]; then
    msg="${run_id}: resume ship"
  fi

  echo "resume state: step=${step:-unknown} branch=${branch:-unknown} pr_url=${pr_url:-none}"
  if [[ -z "$branch" ]]; then
    echo "ERROR: ship_state.json has empty branch."
    print_resume_cmd "$run_id"
    exit 1
  fi

  run_with_retry_capture "resume_fetch" git fetch origin || {
    append_execution_event "$run_id" "resume" "resume_fetch_failed" "fail" "git fetch origin" "" "${RETRY_LAST_ERROR:-fetch failed}"
    print_resume_cmd "$run_id"
    exit 1
  }

  if git show-ref --verify --quiet "refs/heads/${branch}"; then
    run_with_retry_capture "resume_checkout_branch" git checkout "$branch" || {
      append_execution_event "$run_id" "resume" "resume_checkout_failed" "fail" "git checkout $branch" "" "${RETRY_LAST_ERROR:-checkout failed}"
      print_resume_cmd "$run_id"
      exit 1
    }
  else
    run_with_retry_capture "resume_checkout_branch" git checkout -b "$branch" "origin/$branch" || {
      append_execution_event "$run_id" "resume" "resume_checkout_failed" "fail" "git checkout -b $branch origin/$branch" "" "${RETRY_LAST_ERROR:-checkout failed}"
      print_resume_cmd "$run_id"
      exit 1
    }
  fi

  run_with_retry_capture "resume_push" git push -u origin "$branch" || {
    append_execution_event "$run_id" "resume" "resume_push_failed" "fail" "git push -u origin $branch" "" "${RETRY_LAST_ERROR:-push failed}"
    print_resume_cmd "$run_id"
    exit 1
  }

  if [[ -z "$pr_url" || "$pr_url" == "null" ]]; then
    pr_body="Resume ship for ${run_id}."
    if [[ -f "reports/${run_id}/pr_body_excerpt.md" ]]; then
      pr_body="$(cat "reports/${run_id}/pr_body_excerpt.md")"
    fi
    run_with_retry_capture "resume_pr_create" gh pr create --base main --head "$branch" --title "$msg" --body "$pr_body" || {
      append_execution_event "$run_id" "resume" "resume_pr_create_failed" "fail" "gh pr create --base main --head $branch" "" "${RETRY_LAST_ERROR:-pr create failed}"
      print_resume_cmd "$run_id"
      exit 1
    }
    pr_url="$(printf "%s\n" "$RETRY_OUTPUT" | awk '/^https:\/\/github\.com\/.*\/pull\/[0-9]+$/ {print; exit}')"
    if [[ -z "$pr_url" ]]; then
      echo "ERROR: failed to parse PR url from gh output."
      print_resume_cmd "$run_id"
      exit 1
    fi
    echo "PR: $pr_url"
  fi

  run_with_retry_capture "resume_pr_merge_auto" gh pr merge --auto --squash --delete-branch "$pr_url" || true
  run_with_retry_capture "resume_pr_state" gh pr view "$pr_url" --json state -q .state || {
    append_execution_event "$run_id" "resume" "resume_pr_state_failed" "fail" "gh pr view $pr_url --json state -q .state" "" "${RETRY_LAST_ERROR:-pr state failed}"
    print_resume_cmd "$run_id"
    exit 1
  }
  state="$(printf "%s\n" "$RETRY_OUTPUT" | tail -n1 | tr -d '\r')"
  if [[ "$state" != "MERGED" ]]; then
    run_with_retry_capture "resume_pr_merge" gh pr merge --squash --delete-branch "$pr_url" || {
      append_execution_event "$run_id" "resume" "resume_pr_merge_failed" "fail" "gh pr merge --squash --delete-branch $pr_url" "" "${RETRY_LAST_ERROR:-pr merge failed}"
      print_resume_cmd "$run_id"
      exit 1
    }
  fi

  run_with_retry_capture "resume_sync_checkout_main" git checkout main || {
    append_execution_event "$run_id" "resume" "resume_sync_checkout_failed" "fail" "git checkout main" "" "${RETRY_LAST_ERROR:-checkout main failed}"
    print_resume_cmd "$run_id"
    exit 1
  }
  run_with_retry_capture "resume_sync_pull_main" git pull --rebase origin main || {
    append_execution_event "$run_id" "resume" "resume_sync_pull_failed" "fail" "git pull --rebase origin main" "" "${RETRY_LAST_ERROR:-sync pull failed}"
    print_resume_cmd "$run_id"
    exit 1
  }
  append_execution_event "$run_id" "resume" "resume_done" "ok" "tools/qf resume RUN_ID=${run_id}" "pr_url=${pr_url}" ""
  echo "resume done: ${run_id}"
}

subcmd="${1:-}"
case "$subcmd" in
  init)
    shift
    cmd_init "$@"
    ;;
  onboard)
    shift
    cmd_onboard "${1:-}"
    ;;
  ready)
    shift
    cmd_ready "${1:-}"
    ;;
  snapshot)
    shift
    cmd_snapshot "$@"
    ;;
  handoff)
    shift
    cmd_handoff "${1:-}"
    ;;
  plan)
    shift
    cmd_plan "${1:-20}"
    ;;
  do)
    shift
    cmd_do "${1:-}"
    ;;
  resume)
    shift
    cmd_resume "${1:-}"
    ;;
  *)
    usage
    exit 2
    ;;
esac
