#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$repo_root" ]]; then
  echo "ERROR: not inside a git repository."
  exit 1
fi
cd "$repo_root"

QF_RETRY_MAX="${QF_RETRY_MAX:-3}"
QF_RETRY_BASE_SEC="${QF_RETRY_BASE_SEC:-1}"
RETRY_OUTPUT=""
RETRY_LAST_ERROR=""

usage() {
  cat <<'EOF'
Usage:
  tools/qf init
  tools/qf plan [N]
  tools/qf do queue-next
  tools/qf resume RUN_ID=<run-id>
EOF
}

is_dirty() {
  if ! git diff --quiet || ! git diff --cached --quiet || [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
    return 0
  fi
  return 1
}

print_resume_cmd() {
  local run_id="$1"
  if [[ -n "$run_id" ]]; then
    echo "恢复命令：tools/qf resume RUN_ID=${run_id}"
  fi
}

run_with_retry_capture() {
  local step="$1"
  shift
  local attempt=1
  local delay="$QF_RETRY_BASE_SEC"
  local rc=0
  local output=""

  RETRY_OUTPUT=""
  RETRY_LAST_ERROR=""
  while true; do
    set +e
    output="$("$@" 2>&1)"
    rc=$?
    set -e
    if [[ "$rc" -eq 0 ]]; then
      RETRY_OUTPUT="$output"
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output"
      fi
      return 0
    fi

    RETRY_LAST_ERROR="$(printf "%s" "$output" | tail -n 3 | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//')"
    if [[ "$attempt" -ge "$QF_RETRY_MAX" ]]; then
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output" >&2
      fi
      return "$rc"
    fi
    echo "retry[$attempt/$QF_RETRY_MAX] step=$step rc=$rc: ${RETRY_LAST_ERROR:-unknown}" >&2
    sleep "$delay"
    attempt=$((attempt + 1))
    delay=$((delay * 2))
  done
}

auto_stash_if_dirty() {
  local prefix="$1"
  if ! is_dirty; then
    return 0
  fi
  local stash_name="qf-${prefix}-wip-$(date +%Y%m%d-%H%M%S)"
  echo "Detected local changes. Stashing as: ${stash_name}"
  git stash push -u -m "$stash_name" >/dev/null
  local latest_stash
  latest_stash="$(git stash list -1 | head -n1 || true)"
  echo "stashed: ${latest_stash:-$stash_name}"
  echo "恢复指令："
  echo "  git stash list"
  echo "  git stash pop stash@{0}"
}

sync_main() {
  local run_id="$1"
  if [[ "${QF_SKIP_SYNC:-0}" == "1" ]]; then
    echo "sync skipped (QF_SKIP_SYNC=1)"
    return 0
  fi
  if ! run_with_retry_capture "sync_checkout_main" git checkout main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
  if ! run_with_retry_capture "sync_pull_main" git pull --rebase origin main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
}

cleanup_pick_candidate_dirs() {
  if [[ ! -d "reports" ]]; then
    return 0
  fi
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    rm -rf "$dir"
    echo "CLEANED: $dir"
  done < <(find reports -maxdepth 1 -type d -name 'run-*-pick-candidate' | sort)
}

cmd_init() {
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-init}"
  auto_stash_if_dirty "init"
  sync_main "$run_id"
  bash tools/doctor.sh
  bash tools/onboard.sh "$run_id"
  echo "== 下一步建议 =="
  echo "1) tools/qf plan 20"
  echo "2) tools/qf do queue-next"
}

cmd_plan() {
  local n="${1:-20}"
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-plan}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local proposal_copy="${QF_PLAN_COPY_PATH:-/tmp/qf_todo_proposal.md}"

  sync_main "$run_id"
  bash tools/task.sh --plan "$n"

  if [[ -f "$proposal_file" ]]; then
    cp "$proposal_file" "$proposal_copy"
    echo "PROPOSAL_COPY: $proposal_copy"
  else
    echo "ERROR: proposal file missing: $proposal_file"
    exit 1
  fi

  if [[ -f "TASKS/TODO_PROPOSAL.md" ]]; then
    git restore TASKS/TODO_PROPOSAL.md || true
  fi
  cleanup_pick_candidate_dirs

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "ERROR: qf plan polluted working tree."
    git status --porcelain
    exit 1
  fi
}

cmd_do() {
  local target="${1:-}"
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-do}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local output=""
  local task_file=""
  local task_run_id=""
  local evidence_path=""

  if [[ "$target" != "queue-next" ]]; then
    echo "ERROR: only 'queue-next' is supported."
    usage
    exit 2
  fi

  auto_stash_if_dirty "do"
  sync_main "$run_id"

  if [[ ! -f "$proposal_file" ]]; then
    echo "proposal missing; generating with tools/qf plan 20"
    cmd_plan "20"
  fi

  set +e
  output="$(bash tools/task.sh --pick queue-next 2>&1)"
  rc=$?
  set -e
  if [[ "$rc" -ne 0 ]]; then
    printf "%s\n" "$output" >&2
    print_resume_cmd "$run_id"
    exit "$rc"
  fi
  printf "%s\n" "$output"

  task_file="$(printf "%s\n" "$output" | awk -F': ' '/^TASK_FILE:/ {print $2; exit}')"
  task_run_id="$(printf "%s\n" "$output" | awk -F': ' '/^RUN_ID:/ {print $2; exit}')"
  evidence_path="$(printf "%s\n" "$output" | awk -F': ' '/^EVIDENCE_PATH:/ {print $2; exit}')"
  if [[ -n "$task_file" ]]; then
    echo "TASK_FILE: $task_file"
  fi
  if [[ -n "$task_run_id" ]]; then
    echo "RUN_ID: $task_run_id"
  fi
  if [[ -n "$evidence_path" ]]; then
    echo "EVIDENCE_PATH: $evidence_path"
  fi
}

read_state_field() {
  local file="$1"
  local key="$2"
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required for parsing ship_state.json" >&2
    exit 1
  fi
  "$py_bin" - <<'PY' "$file" "$key"
import json
import sys
path, key = sys.argv[1], sys.argv[2]
with open(path, "r", encoding="utf-8") as f:
    obj = json.load(f)
val = obj.get(key, "")
if val is None:
    val = ""
print(str(val))
PY
}

cmd_resume() {
  local arg="${1:-}"
  local run_id=""
  local state_file=""
  local step=""
  local branch=""
  local pr_url=""
  local msg=""
  local pr_body=""
  local state=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    run_id="${arg#RUN_ID=}"
  fi
  if [[ -z "$run_id" ]]; then
    echo "ERROR: resume requires RUN_ID=..."
    usage
    exit 2
  fi

  state_file="reports/${run_id}/ship_state.json"
  if [[ ! -f "$state_file" ]]; then
    echo "ERROR: missing state file: $state_file"
    print_resume_cmd "$run_id"
    exit 1
  fi

  step="$(read_state_field "$state_file" "step")"
  branch="$(read_state_field "$state_file" "branch")"
  pr_url="$(read_state_field "$state_file" "pr_url")"
  msg="$(read_state_field "$state_file" "msg")"
  if [[ -z "$msg" ]]; then
    msg="${run_id}: resume ship"
  fi

  echo "resume state: step=${step:-unknown} branch=${branch:-unknown} pr_url=${pr_url:-none}"
  if [[ -z "$branch" ]]; then
    echo "ERROR: ship_state.json has empty branch."
    print_resume_cmd "$run_id"
    exit 1
  fi

  run_with_retry_capture "resume_fetch" git fetch origin || {
    print_resume_cmd "$run_id"
    exit 1
  }

  if git show-ref --verify --quiet "refs/heads/${branch}"; then
    run_with_retry_capture "resume_checkout_branch" git checkout "$branch" || {
      print_resume_cmd "$run_id"
      exit 1
    }
  else
    run_with_retry_capture "resume_checkout_branch" git checkout -b "$branch" "origin/$branch" || {
      print_resume_cmd "$run_id"
      exit 1
    }
  fi

  run_with_retry_capture "resume_push" git push -u origin "$branch" || {
    print_resume_cmd "$run_id"
    exit 1
  }

  if [[ -z "$pr_url" || "$pr_url" == "null" ]]; then
    pr_body="Resume ship for ${run_id}."
    if [[ -f "reports/${run_id}/pr_body_excerpt.md" ]]; then
      pr_body="$(cat "reports/${run_id}/pr_body_excerpt.md")"
    fi
    run_with_retry_capture "resume_pr_create" gh pr create --base main --head "$branch" --title "$msg" --body "$pr_body" || {
      print_resume_cmd "$run_id"
      exit 1
    }
    pr_url="$(printf "%s\n" "$RETRY_OUTPUT" | awk '/^https:\/\/github\.com\/.*\/pull\/[0-9]+$/ {print; exit}')"
    if [[ -z "$pr_url" ]]; then
      echo "ERROR: failed to parse PR url from gh output."
      print_resume_cmd "$run_id"
      exit 1
    fi
    echo "PR: $pr_url"
  fi

  run_with_retry_capture "resume_pr_merge_auto" gh pr merge --auto --squash --delete-branch "$pr_url" || true
  run_with_retry_capture "resume_pr_state" gh pr view "$pr_url" --json state -q .state || {
    print_resume_cmd "$run_id"
    exit 1
  }
  state="$(printf "%s\n" "$RETRY_OUTPUT" | tail -n1 | tr -d '\r')"
  if [[ "$state" != "MERGED" ]]; then
    run_with_retry_capture "resume_pr_merge" gh pr merge --squash --delete-branch "$pr_url" || {
      print_resume_cmd "$run_id"
      exit 1
    }
  fi

  run_with_retry_capture "resume_sync_checkout_main" git checkout main || {
    print_resume_cmd "$run_id"
    exit 1
  }
  run_with_retry_capture "resume_sync_pull_main" git pull --rebase origin main || {
    print_resume_cmd "$run_id"
    exit 1
  }
  echo "resume done: ${run_id}"
}

subcmd="${1:-}"
case "$subcmd" in
  init)
    shift
    cmd_init "$@"
    ;;
  plan)
    shift
    cmd_plan "${1:-20}"
    ;;
  do)
    shift
    cmd_do "${1:-}"
    ;;
  resume)
    shift
    cmd_resume "${1:-}"
    ;;
  *)
    usage
    exit 2
    ;;
esac
