#!/usr/bin/env bash
set -euo pipefail

repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [[ -z "$repo_root" ]]; then
  echo "ERROR: not inside a git repository."
  exit 1
fi
cd "$repo_root"

QF_RETRY_MAX="${QF_RETRY_MAX:-3}"
QF_RETRY_BASE_SEC="${QF_RETRY_BASE_SEC:-1}"
RETRY_OUTPUT=""
RETRY_LAST_ERROR=""
STATE_FILE="${QF_STATE_FILE:-TASKS/STATE.md}"
REQUIRED_READY_FILE=""

usage() {
  cat <<'EOF'
Usage:
  tools/qf init
  tools/qf onboard RUN_ID
  tools/qf ready [RUN_ID=<run-id>]
  tools/qf snapshot [RUN_ID=<run-id>] NOTE=<text>
  tools/qf handoff [RUN_ID=<run-id>]
  tools/qf exam [RUN_ID=<run-id>] [ANSWER_FILE=<path>] [RUBRIC_FILE=<path>] [OUTPUT_FILE=<path>]
  tools/qf exam-auto [RUN_ID=<run-id>] [ANSWER_FILE=<path>] [RUBRIC_FILE=<path>] [OUTPUT_FILE=<path>] [AUTO_FILL=0|1]
  tools/qf plan [N]
  tools/qf do queue-next
  tools/qf resume [RUN_ID=<run-id>]
  tools/qf stash-clean [preview|apply] [KEEP=<n>]
EOF
}

is_dirty() {
  if ! git diff --quiet || ! git diff --cached --quiet || [[ -n "$(git ls-files --others --exclude-standard)" ]]; then
    return 0
  fi
  return 1
}

print_resume_cmd() {
  local run_id="$1"
  if [[ -n "$run_id" ]]; then
    echo "恢复命令：tools/qf resume RUN_ID=${run_id}"
  fi
}

json_escape() {
  local value="${1:-}"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/}"
  printf "%s" "$value"
}

redact_text() {
  local value="${1:-}"
  if [[ "${QF_LOG_REDACT:-1}" != "1" ]]; then
    printf "%s" "$value"
    return 0
  fi
  printf "%s" "$value" | sed -E \
    -e 's/(token|password|passwd|secret|api[_-]?key)[[:space:]]*=[[:space:]]*[^[:space:]]+/\1=<redacted>/Ig' \
    -e 's/(Authorization:[[:space:]]*Bearer)[[:space:]]+[A-Za-z0-9._-]+/\1 <redacted>/Ig' \
    -e 's/\b(ghp_[A-Za-z0-9]+)\b/<redacted>/g' \
    -e 's/\b(sk-[A-Za-z0-9]+)\b/<redacted>/g'
}

append_execution_event() {
  local run_id="$1"
  local phase="$2"
  local action="$3"
  local status="$4"
  local command="${5:-}"
  local artifacts="${6:-}"
  local error="${7:-}"
  local file=""
  local command_r=""
  local artifacts_r=""
  local error_r=""
  local max_len="${QF_LOG_MAX_LEN:-200}"

  if [[ -z "$run_id" || "${QF_LOG_DISABLE:-0}" == "1" ]]; then
    return 0
  fi

  command_r="$(redact_text "$command")"
  artifacts_r="$(redact_text "$artifacts")"
  error_r="$(redact_text "$error")"
  if [[ "${#command_r}" -gt "$max_len" ]]; then
    command_r="${command_r:0:${max_len}}...(truncated)"
  fi
  if [[ "${#artifacts_r}" -gt "$max_len" ]]; then
    artifacts_r="${artifacts_r:0:${max_len}}...(truncated)"
  fi
  if [[ "${#error_r}" -gt "$max_len" ]]; then
    error_r="${error_r:0:${max_len}}...(truncated)"
  fi

  file="reports/${run_id}/execution.jsonl"
  mkdir -p "reports/${run_id}"
  printf '{"ts":"%s","run_id":"%s","phase":"%s","action":"%s","status":"%s","command":"%s","artifacts":"%s","error":"%s"}\n' \
    "$(date -Iseconds)" \
    "$(json_escape "$run_id")" \
    "$(json_escape "$phase")" \
    "$(json_escape "$action")" \
    "$(json_escape "$status")" \
    "$(json_escape "$command_r")" \
    "$(json_escape "$artifacts_r")" \
    "$(json_escape "$error_r")" >> "$file"
}

state_field_value() {
  local key="$1"
  local py_bin=""
  if [[ ! -f "$STATE_FILE" ]]; then
    printf ""
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    printf ""
    return 0
  fi
  "$py_bin" - <<'PY' "$STATE_FILE" "$key"
import re
import sys

path, key = sys.argv[1], sys.argv[2]
pat = re.compile(rf"^\s*{re.escape(key)}:\s*(.*?)\s*$")
try:
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            m = pat.match(line.rstrip("\n"))
            if m:
                print(m.group(1))
                raise SystemExit(0)
except FileNotFoundError:
    pass
print("")
PY
}

resolve_state_current_run_id() {
  local run_id=""
  run_id="$(state_field_value "CURRENT_RUN_ID")"
  if [[ -n "$run_id" ]]; then
    printf "%s" "$run_id"
    return 0
  fi
  printf ""
  return 1
}

resolve_latest_report_run_id() {
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    printf ""
    return 1
  fi
  "$py_bin" - <<'PY'
from pathlib import Path

root = Path("reports")
if not root.exists():
    raise SystemExit(0)

cands = []
for d in root.glob("run-*"):
    if not d.is_dir():
        continue
    mt = 0.0
    for name in ("ready.json", "execution.jsonl", "conversation.md", "handoff.md", "decision.md", "summary.md", "ship_state.json"):
        p = d / name
        if p.exists():
            mt = max(mt, p.stat().st_mtime)
    if mt > 0:
        cands.append((mt, d.name))

if cands:
    cands.sort(reverse=True)
    print(cands[0][1])
PY
}

resolve_run_id_for_cmd() {
  local explicit_run_id="${1:-}"
  local context="${2:-cmd}"
  local state_run_id=""
  local latest_run_id=""

  state_run_id="$(resolve_state_current_run_id || true)"
  if [[ -n "$explicit_run_id" ]]; then
    if [[ -n "$state_run_id" && "$explicit_run_id" != "$state_run_id" && "${QF_ALLOW_RUN_ID_MISMATCH:-0}" != "1" ]]; then
      echo "ERROR: ${context} run-id mismatch." >&2
      echo "  explicit: ${explicit_run_id}" >&2
      echo "  CURRENT_RUN_ID (TASKS/STATE.md): ${state_run_id}" >&2
      echo "  Fix: update TASKS/STATE.md or pass QF_ALLOW_RUN_ID_MISMATCH=1 for one-time override." >&2
      return 1
    fi
    printf "%s" "$explicit_run_id"
    return 0
  fi

  if [[ -n "$state_run_id" ]]; then
    printf "%s" "$state_run_id"
    return 0
  fi

  latest_run_id="$(resolve_latest_report_run_id || true)"
  if [[ -n "$latest_run_id" ]]; then
    echo "WARN: ${context} fallback to latest report run-id: ${latest_run_id}" >&2
    printf "%s" "$latest_run_id"
    return 0
  fi

  printf ""
  return 0
}

update_state_current() {
  local run_id="${1:-}"
  local task_file="${2:-}"
  local status="${3:-active}"
  local py_bin=""

  if [[ "${QF_STATE_UPDATE_DISABLE:-0}" == "1" ]]; then
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    return 0
  fi

  "$py_bin" - <<'PY' "$STATE_FILE" "$run_id" "$task_file" "$status"
import re
import sys
from datetime import datetime, timezone
from pathlib import Path

state_file, run_id, task_file, status = sys.argv[1:]
path = Path(state_file)
if path.exists():
    lines = path.read_text(encoding="utf-8").splitlines()
else:
    lines = ["# STATE", ""]

keys = {"CURRENT_RUN_ID", "CURRENT_TASK_FILE", "CURRENT_STATUS", "CURRENT_UPDATED_AT"}
filtered = []
for line in lines:
    matched = False
    for key in keys:
        if re.match(rf"^\s*{re.escape(key)}\s*:", line):
            matched = True
            break
    if not matched:
        filtered.append(line)

insert_idx = 0
if filtered and filtered[0].startswith("#"):
    insert_idx = 1
    if len(filtered) > 1 and filtered[1].strip() == "":
        insert_idx = 2

meta = [
    f"CURRENT_RUN_ID: {run_id}",
    f"CURRENT_TASK_FILE: {task_file}",
    f"CURRENT_STATUS: {status}",
    f"CURRENT_UPDATED_AT: {datetime.now(timezone.utc).replace(microsecond=0).isoformat()}",
    "",
]
out = filtered[:insert_idx] + meta + filtered[insert_idx:]
path.parent.mkdir(parents=True, exist_ok=True)
path.write_text("\n".join(out).rstrip() + "\n", encoding="utf-8")
PY
}

run_with_retry_capture() {
  local step="$1"
  shift
  local attempt=1
  local delay="$QF_RETRY_BASE_SEC"
  local rc=0
  local output=""

  RETRY_OUTPUT=""
  RETRY_LAST_ERROR=""
  while true; do
    set +e
    output="$("$@" 2>&1)"
    rc=$?
    set -e
    if [[ "$rc" -eq 0 ]]; then
      RETRY_OUTPUT="$output"
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output"
      fi
      return 0
    fi

    RETRY_LAST_ERROR="$(printf "%s" "$output" | tail -n 3 | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//')"
    if [[ "$attempt" -ge "$QF_RETRY_MAX" ]]; then
      if [[ -n "$output" ]]; then
        printf "%s\n" "$output" >&2
      fi
      return "$rc"
    fi
    echo "retry[$attempt/$QF_RETRY_MAX] step=$step rc=$rc: ${RETRY_LAST_ERROR:-unknown}" >&2
    sleep "$delay"
    attempt=$((attempt + 1))
    delay=$((delay * 2))
  done
}

auto_stash_if_dirty() {
  local prefix="$1"
  if ! is_dirty; then
    return 0
  fi
  if [[ "${QF_AUTOSTASH:-1}" != "1" ]]; then
    echo "❌ 工作区不干净（有未提交改动）"
    echo "   修复：先处理未提交改动，或设置 QF_AUTOSTASH=1 后重试。"
    return 1
  fi
  local stash_name="qf-${prefix}-wip-$(date +%Y%m%d-%H%M%S)"
  echo "Detected local changes. Stashing as: ${stash_name}"
  git stash push -u -m "$stash_name" >/dev/null
  local latest_stash
  latest_stash="$(git stash list -1 | head -n1 || true)"
  echo "stashed: ${latest_stash:-$stash_name}"
  echo "恢复指令："
  echo "  git stash list"
  echo "  git stash pop stash@{0}"
}

cmd_onboard() {
  local run_id="${1:-${RUN_ID:-}}"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: RUN_ID is required. Usage: tools/qf onboard <RUN_ID>" >&2
    exit 2
  fi

  local repo_root reports_dir out_dir out_file state_file queue_file decisions_glob recent_limit tmp_recent
  repo_root="${ONBOARD_REPO_ROOT:-.}"
  reports_dir="${ONBOARD_REPORTS_DIR:-${repo_root}/reports}"
  out_dir="${ONBOARD_OUT_DIR:-${reports_dir}/${run_id}}"
  out_file="${out_dir}/onboard.md"
  state_file="${ONBOARD_STATE_FILE:-${repo_root}/TASKS/STATE.md}"
  queue_file="${ONBOARD_QUEUE_FILE:-${repo_root}/TASKS/QUEUE.md}"
  decisions_glob="${ONBOARD_DECISIONS_GLOB:-${reports_dir}/run-*/decision.md}"
  recent_limit="${ONBOARD_RECENT_LIMIT:-8}"

  mkdir -p "$out_dir"
  tmp_recent="$(mktemp)"
  trap 'rm -f "${tmp_recent:-}"' RETURN

  # shellcheck disable=SC2086
  ls -1t ${decisions_glob} 2>/dev/null | head -n "${recent_limit}" > "$tmp_recent" || true

  {
    echo "# Session Onboard"
    echo
    echo "RUN_ID: \`${run_id}\`"
    echo "Generated At: $(date -Iseconds)"
    echo
    echo "## 宪法/硬规则入口"
    echo "- AGENTS.md"
    echo
    echo "## 项目背景/阶段入口"
    echo "- docs/PROJECT_GUIDE.md"
    echo
    echo "## 工作流入口"
    echo "- docs/WORKFLOW.md"
    echo "- TASKS/STATE.md"
    echo "- TASKS/QUEUE.md"
    echo
    echo "## 强制复述模板入口"
    echo "- docs/PROJECT_GUIDE.md#强制复述模板"
    echo
    echo "## 最近 decision 入口列表"
    if [[ -s "$tmp_recent" ]]; then
      while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        rel="${item#${repo_root}/}"
        echo "- ${rel}"
      done < "$tmp_recent"
    else
      echo "- 无（未检出 reports/run-*/decision.md）"
    fi
    echo
    echo "## 快速检查"
    if [[ -f "$state_file" ]]; then
      echo "- STATE: ${state_file#${repo_root}/}"
    else
      echo "- STATE: missing (${state_file})"
    fi
    if [[ -f "$queue_file" ]]; then
      echo "- QUEUE: ${queue_file#${repo_root}/}"
    else
      echo "- QUEUE: missing (${queue_file})"
    fi
  } | tee "$out_file"

  echo "ONBOARD_FILE: $out_file"
}

extract_task_goal_default() {
  local task_file="$1"
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    printf ""
    return 0
  fi
  awk '
    BEGIN { in_goal = 0 }
    /^##[[:space:]]+Goal/ { in_goal = 1; next }
    in_goal && /^##[[:space:]]+/ { exit }
    in_goal {
      line=$0
      sub(/\r$/, "", line)
      if (line ~ /[[:graph:]]/) {
        gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
        print line
        exit
      }
    }
  ' "$task_file"
}

extract_task_scope_default() {
  local task_file="$1"
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    printf ""
    return 0
  fi
  awk '
    BEGIN { in_scope = 0; out = "" }
    /^##[[:space:]]+Scope/ { in_scope = 1; next }
    in_scope && /^##[[:space:]]+/ { exit }
    in_scope && /^[[:space:]]*-[[:space:]]*/ {
      line=$0
      sub(/^[[:space:]]*-[[:space:]]*/, "", line)
      gsub(/`/, "", line)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
      if (line != "") {
        if (out != "") out = out ", "
        out = out line
      }
    }
    END {
      if (out != "") print out
    }
  ' "$task_file"
}

extract_task_acceptance_default() {
  local task_file="$1"
  if [[ -z "$task_file" || ! -f "$task_file" ]]; then
    printf ""
    return 0
  fi
  awk '
    BEGIN { in_accept = 0; out = "" }
    /^##[[:space:]]+Acceptance/ { in_accept = 1; next }
    in_accept && /^##[[:space:]]+/ { exit }
    in_accept && /^[[:space:]]*-[[:space:]]*/ {
      line=$0
      sub(/^[[:space:]]*-[[:space:]]*/, "", line)
      sub(/^\[[ xX]\][[:space:]]*/, "", line)
      gsub(/`/, "", line)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", line)
      if (line != "") {
        if (out != "") out = out "; "
        out = out line
      }
    }
    END {
      if (out != "") print out
    }
  ' "$task_file"
}

resolve_ready_field() {
  local env_key="$1"
  local prompt="$2"
  local default_value="${3:-}"
  local auto_mode="${QF_READY_AUTO:-1}"
  local value="${!env_key:-}"
  if [[ -n "$value" ]]; then
    printf "%s" "$value"
    return 0
  fi
  if [[ "$auto_mode" == "1" && -n "$default_value" ]]; then
    printf "%s" "$default_value"
    return 0
  fi
  if [[ -t 0 ]]; then
    echo -n "$prompt"
    IFS= read -r value
    printf "%s" "$value"
    return 0
  fi
  echo "ERROR: missing $env_key and no interactive stdin for prompt: $prompt" >&2
  return 1
}

cmd_ready() {
  local arg="${1:-}"
  local run_id=""
  local explicit_run_id=""
  local goal scope acceptance steps stop
  local goal_default scope_default acceptance_default steps_default stop_default
  local task_file=""
  local ready_file=""
  local py_bin=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    explicit_run_id="${arg#RUN_ID=}"
  elif [[ -n "$arg" ]]; then
    explicit_run_id="$arg"
  elif [[ -n "${RUN_ID:-}" ]]; then
    explicit_run_id="${RUN_ID}"
  fi

  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "ready")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: ready requires RUN_ID (from explicit arg/env or TASKS/STATE.md CURRENT_RUN_ID)." >&2
    echo "Usage: tools/qf ready [RUN_ID=<run-id>]" >&2
    exit 2
  fi

  task_file="$(state_field_value "CURRENT_TASK_FILE")"
  goal_default="$(extract_task_goal_default "$task_file")"
  scope_default="$(extract_task_scope_default "$task_file")"
  acceptance_default="$(extract_task_acceptance_default "$task_file")"
  if [[ -z "$goal_default" ]]; then
    goal_default="Continue ${run_id} with a scoped, minimal, verifiable change."
  fi
  if [[ -z "$scope_default" ]]; then
    if [[ -n "$task_file" ]]; then
      scope_default="Follow declared scope in ${task_file}"
    else
      scope_default="Follow active task scope"
    fi
  fi
  if [[ -z "$acceptance_default" ]]; then
    acceptance_default="make verify; update reports/{RUN_ID}/summary.md and reports/{RUN_ID}/decision.md; keep scope clean"
  fi
  steps_default="evidence -> implement -> verify -> reports -> ship"
  stop_default="finish and wait for next instruction; if blocked, record stop reason in decision.md"

  goal="$(resolve_ready_field "QF_READY_GOAL" "Goal (one sentence): " "$goal_default")" || exit 1
  scope="$(resolve_ready_field "QF_READY_SCOPE" "Scope (exact paths): " "$scope_default")" || exit 1
  acceptance="$(resolve_ready_field "QF_READY_ACCEPTANCE" "Acceptance (verify/evidence/scope): " "$acceptance_default")" || exit 1
  steps="$(resolve_ready_field "QF_READY_STEPS" "Execution steps: " "$steps_default")" || exit 1
  stop="$(resolve_ready_field "QF_READY_STOP" "Stop condition: " "$stop_default")" || exit 1

  if [[ -z "$goal" || -z "$scope" || -z "$acceptance" || -z "$steps" || -z "$stop" ]]; then
    echo "ERROR: ready fields cannot be empty." >&2
    exit 1
  fi

  mkdir -p "reports/${run_id}"
  ready_file="reports/${run_id}/ready.json"

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required to write ready.json" >&2
    exit 1
  fi

  "$py_bin" - <<'PY' "$ready_file" "$run_id" "$goal" "$scope" "$acceptance" "$steps" "$stop"
import json
import sys
from datetime import datetime, timezone

out, run_id, goal, scope, acceptance, steps, stop = sys.argv[1:]
obj = {
    "run_id": run_id,
    "created_at_utc": datetime.now(timezone.utc).isoformat(),
    "constitution_read": True,
    "workflow_read": True,
    "restatement_passed": True,
    "restatement": {
        "goal": goal,
        "scope": scope,
        "acceptance": acceptance,
        "steps": steps,
        "stop_condition": stop,
    },
}
with open(out, "w", encoding="utf-8") as f:
    json.dump(obj, f, ensure_ascii=False, indent=2)
    f.write("\n")
PY

  append_execution_event "$run_id" "ready" "ready_passed" "ok" "tools/qf ready" "ready_file=${ready_file};task_file=${task_file}" ""
  update_state_current "$run_id" "$(state_field_value "CURRENT_TASK_FILE")" "active"
  echo "READY_FILE: $ready_file"
  echo "READY_RUN_ID: $run_id"
  if [[ -n "$task_file" ]]; then
    echo "READY_TASK_FILE: $task_file"
  fi
}

cmd_snapshot() {
  local run_id=""
  local explicit_run_id="${RUN_ID:-}"
  local note="${QF_SNAPSHOT_NOTE:-}"
  local arg=""
  local snapshot_file=""
  local now_iso=""
  local branch=""
  local head=""
  local status_line=""
  local current_status=""

  for arg in "$@"; do
    case "$arg" in
      RUN_ID=*)
        explicit_run_id="${arg#RUN_ID=}"
        ;;
      NOTE=*)
        note="${arg#NOTE=}"
        ;;
      *)
        if [[ -z "$explicit_run_id" ]]; then
          explicit_run_id="$arg"
        elif [[ -z "$note" ]]; then
          note="$arg"
        fi
        ;;
    esac
  done

  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "snapshot")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: snapshot requires RUN_ID (explicit or TASKS/STATE.md CURRENT_RUN_ID)." >&2
    exit 2
  fi

  mkdir -p "reports/${run_id}"
  snapshot_file="reports/${run_id}/conversation.md"
  now_iso="$(date -Iseconds)"
  branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")"
  head="$(git rev-parse --short HEAD 2>/dev/null || echo "none")"
  if is_dirty; then
    status_line="dirty"
  else
    status_line="clean"
  fi

  {
    echo "## ${now_iso}"
    echo "- branch: \`${branch}\`"
    echo "- head: \`${head}\`"
    echo "- working_tree: \`${status_line}\`"
    if [[ -n "$note" ]]; then
      echo "- note: ${note}"
    else
      echo "- note: (empty)"
    fi
    echo
  } >> "$snapshot_file"

  current_status="$(state_field_value "CURRENT_STATUS")"
  if [[ -z "$current_status" ]]; then
    current_status="active"
  fi
  update_state_current "$run_id" "$(state_field_value "CURRENT_TASK_FILE")" "$current_status"
  echo "SNAPSHOT_FILE: $snapshot_file"
  echo "SNAPSHOT_RUN_ID: $run_id"
}

cmd_handoff() {
  local arg="${1:-}"
  local run_id=""
  local explicit_run_id=""
  local ready_file=""
  local convo_file=""
  local exec_file=""
  local ship_file=""
  local out_file=""
  local py_bin=""
  local current_status=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    explicit_run_id="${arg#RUN_ID=}"
  elif [[ -n "$arg" ]]; then
    explicit_run_id="$arg"
  elif [[ -n "${RUN_ID:-}" ]]; then
    explicit_run_id="${RUN_ID}"
  fi

  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "handoff")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: handoff requires RUN_ID (explicit or TASKS/STATE.md CURRENT_RUN_ID)." >&2
    exit 2
  fi

  ready_file="reports/${run_id}/ready.json"
  convo_file="reports/${run_id}/conversation.md"
  exec_file="reports/${run_id}/execution.jsonl"
  ship_file="reports/${run_id}/ship_state.json"
  out_file="reports/${run_id}/handoff.md"
  mkdir -p "reports/${run_id}"

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required to generate handoff.md" >&2
    exit 1
  fi

  "$py_bin" - <<'PY' "$run_id" "$ready_file" "$convo_file" "$exec_file" "$ship_file" "$out_file"
import json
import os
import sys
from datetime import datetime, timezone

run_id, ready_file, convo_file, exec_file, ship_file, out_file = sys.argv[1:]

def tail_lines(path: str, n: int) -> list[str]:
    if not os.path.exists(path):
        return []
    with open(path, "r", encoding="utf-8") as f:
        lines = f.readlines()
    return [x.rstrip("\n") for x in lines[-n:]]

def read_ready(path: str) -> dict:
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def read_ship(path: str) -> dict:
    if not os.path.exists(path):
        return {}
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def read_exec_tail(path: str, n: int) -> list[dict]:
    if not os.path.exists(path):
        return []
    items = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except Exception:
                continue
    return items[-n:]

def short_text(value: str, max_len: int = 120) -> str:
    v = (value or "").strip()
    if len(v) <= max_len:
        return v
    return v[:max_len] + "...(truncated)"

def extract_notes(lines: list[str], n: int) -> list[str]:
    notes = []
    for line in lines:
        s = line.strip()
        if not s:
            continue
        if s.startswith("- note:"):
            notes.append(s[len("- note:"):].strip())
        elif s.startswith("- "):
            notes.append(s[2:].strip())
    out = []
    for x in notes[-n:]:
        x = short_text(x, 160)
        if x:
            out.append(x)
    return out

ready = read_ready(ready_file)
ship = read_ship(ship_file)
exec_tail = read_exec_tail(exec_file, 8)
convo_tail = tail_lines(convo_file, 20)
notes = extract_notes(convo_tail, 3)

if not ready:
    next_cmd = "tools/qf ready"
elif ship and ship.get("last_error"):
    next_cmd = "tools/qf resume"
else:
    next_cmd = "tools/qf plan 20"

missing = []
for p in (ready_file, convo_file, exec_file, ship_file):
    if not os.path.exists(p):
        missing.append(p)

latest_event = {}
if exec_tail:
    latest_event = exec_tail[-1]

main_lines = []
if notes:
    for n in notes:
        main_lines.append(f"- {n}")
else:
    main_lines.append("- missing: conversation.md")
    if ready:
        rst = ready.get("restatement", {})
        if rst.get("goal"):
            main_lines.append(f"- 目标复述：{short_text(str(rst.get('goal')), 160)}")

conclusion_lines = []
if ready:
    rst = ready.get("restatement", {})
    conclusion_lines.append("- ready 门禁：已通过。")
    if rst.get("goal"):
        conclusion_lines.append(f"- 当前目标：{short_text(str(rst.get('goal')), 160)}")
else:
    conclusion_lines.append("- ready 门禁：未通过（missing: ready.json）。")

if latest_event:
    phase = latest_event.get("phase", "")
    action = latest_event.get("action", "")
    status = latest_event.get("status", "")
    artifacts = short_text(str(latest_event.get("artifacts", "")), 120)
    conclusion_lines.append(f"- 最近执行：{phase}/{action} ({status}) {artifacts}".rstrip())
elif not os.path.exists(exec_file):
    conclusion_lines.append("- 执行轨迹：missing: execution.jsonl。")

if ship:
    step = ship.get("step", "(missing)")
    pr_url = ship.get("pr_url", "(none)")
    last_error = ship.get("last_error", "")
    conclusion_lines.append(f"- 交付状态：step={step}, pr={pr_url}")
    if last_error:
        conclusion_lines.append(f"- 交付异常：{short_text(str(last_error), 160)}")
elif not os.path.exists(ship_file):
    conclusion_lines.append("- 交付状态：missing: ship_state.json。")

thinking_lines = []
if any((x.get("status") == "fail") for x in exec_tail):
    thinking_lines.append("- 最近出现失败事件，建议先 `tools/qf resume` 处理恢复，再继续新任务。")
elif missing:
    thinking_lines.append("- 接班信息有缺口；后续在关键决策点执行 `tools/qf snapshot NOTE=\"...\"` 提升连续性。")
else:
    thinking_lines.append("- 当前信息链完整，建议保持“短总结 + 证据链接”节奏，避免文档噪音。")

lines = []
lines.append("# Session 总结")
lines.append("")
lines.append(f"RUN_ID: `{run_id}`")
lines.append(f"Generated At: {datetime.now(timezone.utc).isoformat()}")
lines.append("")
lines.append("## 本次沟通主线")
lines.extend(main_lines)
lines.append("")
lines.append("## 关键结论")
lines.extend(conclusion_lines)
lines.append("")
lines.append("## 少量思考摘要")
lines.extend(thinking_lines)
lines.append("")
lines.append("## 下一步（单条）")
lines.append(f"- {next_cmd}")
lines.append("")
lines.append("## 缺失输入（可选补齐）")
if missing:
    for p in missing:
        lines.append(f"- {p}")
else:
    lines.append("- none")

with open(out_file, "w", encoding="utf-8") as f:
    f.write("\n".join(lines) + "\n")
PY

  append_execution_event "$run_id" "handoff" "handoff_generated" "ok" "tools/qf handoff RUN_ID=${run_id}" "handoff_file=${out_file}" ""
  current_status="$(state_field_value "CURRENT_STATUS")"
  if [[ -z "$current_status" ]]; then
    current_status="active"
  fi
  update_state_current "$run_id" "$(state_field_value "CURRENT_TASK_FILE")" "$current_status"
  echo "HANDOFF_FILE: $out_file"
  echo "HANDOFF_RUN_ID: $run_id"
}

ready_file_is_valid() {
  local ready_file="$1"
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    return 1
  fi
  "$py_bin" - <<'PY' "$ready_file"
import json
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        obj = json.load(f)
except Exception:
    raise SystemExit(1)
if not obj.get("restatement_passed"):
    raise SystemExit(1)
print(path)
PY
}

resolve_ready_file() {
  local ready_file=""
  if [[ -n "${QF_READY_RUN_ID:-}" ]]; then
    ready_file="reports/${QF_READY_RUN_ID}/ready.json"
    if [[ -f "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
      printf "%s" "$ready_file"
      return 0
    fi
    printf ""
    return 1
  fi

  local current_run_id=""
  current_run_id="$(resolve_state_current_run_id || true)"
  if [[ -n "$current_run_id" ]]; then
    ready_file="reports/${current_run_id}/ready.json"
    if [[ -f "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
      printf "%s" "$ready_file"
      return 0
    fi
  fi

  ready_file="$(ls -1t reports/run-*/ready.json 2>/dev/null | head -n1 || true)"
  if [[ -n "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
    printf "%s" "$ready_file"
    return 0
  fi

  printf ""
  return 1
}

resolve_ready_file_for_run() {
  local run_id="${1:-}"
  local ready_file=""
  if [[ -n "$run_id" ]]; then
    ready_file="reports/${run_id}/ready.json"
    if [[ -f "$ready_file" ]] && ready_file_is_valid "$ready_file" >/dev/null 2>&1; then
      printf "%s" "$ready_file"
      return 0
    fi
    printf ""
    return 1
  fi
  resolve_ready_file
}

require_ready_gate() {
  local requested_run_id="${1:-}"
  local ready_file=""
  ready_file="$(resolve_ready_file_for_run "$requested_run_id" || true)"
  if [[ -z "$ready_file" ]]; then
    echo "ERROR: readiness gate not satisfied." >&2
    if [[ -n "$requested_run_id" ]]; then
      echo "Expected ready marker: reports/${requested_run_id}/ready.json" >&2
    fi
    echo "Run: tools/qf ready" >&2
    echo "Then retry: tools/qf do queue-next" >&2
    exit 1
  fi
  REQUIRED_READY_FILE="$ready_file"
  echo "READY_FILE: $ready_file"
}

sync_main() {
  local run_id="$1"
  if [[ "${QF_SKIP_SYNC:-0}" == "1" ]]; then
    echo "sync skipped (QF_SKIP_SYNC=1)"
    return 0
  fi
  if ! run_with_retry_capture "sync_checkout_main" git checkout main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
  if ! run_with_retry_capture "sync_pull_main" git pull --rebase origin main; then
    print_resume_cmd "$run_id"
    exit 1
  fi
}

cleanup_pick_candidate_dirs() {
  if [[ ! -d "reports" ]]; then
    return 0
  fi
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue
    rm -rf "$dir"
    echo "CLEANED: $dir"
  done < <(find reports -maxdepth 1 -type d -name 'run-*-pick-candidate' | sort)
}

cmd_init() {
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-init}"
  local init_auto_handoff="${QF_INIT_AUTO_HANDOFF:-1}"
  local knowledge_file="docs/CHANGELOG_KNOWLEDGE.md"
  local knowledge_ttl_days="${QF_KNOWLEDGE_TTL_DAYS:-14}"
  local last_review=""
  local now_epoch=""
  local reviewed_epoch=""
  local age_days=""
  local latest_handoff_run=""
  local current_run_id=""
  local handoff_done=0
  local py_bin=""
  cleanup_pick_candidate_dirs
  auto_stash_if_dirty "init"
  sync_main "$run_id"
  bash tools/doctor.sh
  cmd_onboard "$run_id"
  if [[ -f "$knowledge_file" ]]; then
    last_review="$(awk '/^- Date: `/ { gsub(/^- Date: `/, "", $0); gsub(/`$/, "", $0); print; exit }' "$knowledge_file" || true)"
    if [[ -n "$last_review" ]]; then
      now_epoch="$(date +%s)"
      reviewed_epoch="$(date -d "$last_review" +%s 2>/dev/null || true)"
      if [[ -n "$reviewed_epoch" ]]; then
        age_days="$(( (now_epoch - reviewed_epoch) / 86400 ))"
        if [[ "$age_days" -gt "$knowledge_ttl_days" ]]; then
          echo "⚠️ Knowledge TTL exceeded: last review ${last_review} (${age_days}d > ${knowledge_ttl_days}d)."
          echo "   建议先执行 knowledge-sync 任务再继续开发。"
        else
          echo "Knowledge review age: ${age_days}d (ttl=${knowledge_ttl_days}d)"
        fi
      fi
    fi
  else
    echo "⚠️ Missing ${knowledge_file}; recommend creating weekly knowledge-sync task."
  fi

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  fi
  if [[ -n "$py_bin" ]]; then
    latest_handoff_run="$("$py_bin" - <<'PY'
from pathlib import Path
root = Path("reports")
if not root.exists():
    raise SystemExit(0)
cands = []
for d in root.glob("run-*"):
    if not d.is_dir():
        continue
    hits = [d / "execution.jsonl", d / "conversation.md", d / "ship_state.json"]
    mt = 0.0
    ok = False
    for p in hits:
        if p.exists():
            ok = True
            mt = max(mt, p.stat().st_mtime)
    if ok:
        cands.append((mt, d.name))
if cands:
    cands.sort(reverse=True)
    print(cands[0][1])
PY
)"
  fi

  current_run_id="$(resolve_state_current_run_id || true)"
  if [[ -n "$current_run_id" && "$init_auto_handoff" == "1" ]]; then
    echo "AUTO_HANDOFF: tools/qf handoff RUN_ID=${current_run_id}"
    cmd_handoff "RUN_ID=${current_run_id}"
    handoff_done=1
  fi
  echo "INIT_RUN_ID: $run_id"
  append_execution_event "$run_id" "init" "init_completed" "ok" "tools/qf init" "onboard_file=reports/${run_id}/onboard.md" ""
  echo "== 下一步建议 =="
  if [[ "$handoff_done" -eq 1 ]]; then
    echo "0) handoff completed for CURRENT_RUN_ID=${current_run_id}"
  elif [[ -n "$current_run_id" ]]; then
    echo "0) tools/qf handoff RUN_ID=${current_run_id}"
    echo "CURRENT_RUN_ID: ${current_run_id}"
  elif [[ -n "$latest_handoff_run" ]]; then
    echo "0) tools/qf handoff RUN_ID=${latest_handoff_run}"
  fi
  echo "1) tools/qf ready"
  echo "2) tools/qf plan 20"
  echo "3) tools/qf do queue-next"
}

cmd_plan() {
  local n="${1:-20}"
  local run_id="${RUN_ID:-run-$(date +%Y-%m-%d)-qf-plan}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local proposal_copy="${QF_PLAN_COPY_PATH:-/tmp/qf_todo_proposal.md}"

  sync_main "$run_id"
  bash tools/task.sh --plan "$n"

  if [[ -f "$proposal_file" ]]; then
    cp "$proposal_file" "$proposal_copy"
    echo "PROPOSAL_COPY: $proposal_copy"
  else
    echo "ERROR: proposal file missing: $proposal_file"
    exit 1
  fi

  if [[ -f "TASKS/TODO_PROPOSAL.md" ]]; then
    git restore TASKS/TODO_PROPOSAL.md || true
  fi
  cleanup_pick_candidate_dirs

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "ERROR: qf plan polluted working tree."
    git status --porcelain
    exit 1
  fi
}

cmd_do() {
  local target="${1:-}"
  local run_id=""
  local explicit_run_id="${RUN_ID:-}"
  local proposal_file="${TASK_PLAN_OUTPUT_FILE:-TASKS/TODO_PROPOSAL.md}"
  local output=""
  local task_file=""
  local task_run_id=""
  local evidence_path=""
  local ready_file=""

  if [[ "$target" != "queue-next" ]]; then
    echo "ERROR: only 'queue-next' is supported."
    usage
    exit 2
  fi

  cleanup_pick_candidate_dirs
  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "do")"
  require_ready_gate "$run_id"
  ready_file="$REQUIRED_READY_FILE"
  if [[ -n "$ready_file" ]]; then
    run_id="$(basename "$(dirname "$ready_file")")"
  elif [[ -z "$run_id" ]]; then
    run_id="run-$(date +%Y-%m-%d)-qf-do"
  fi
  auto_stash_if_dirty "do"
  append_execution_event "$run_id" "do" "do_start" "ok" "tools/qf do queue-next" "" ""
  sync_main "$run_id"

  if [[ ! -f "$proposal_file" ]]; then
    echo "proposal missing; generating with tools/qf plan 20"
    append_execution_event "$run_id" "do" "do_autoplan" "ok" "tools/qf plan 20" "" ""
    cmd_plan "20"
  fi

  set +e
  output="$(bash tools/task.sh --pick queue-next 2>&1)"
  rc=$?
  set -e
  if [[ "$rc" -ne 0 ]]; then
    printf "%s\n" "$output" >&2
    append_execution_event "$run_id" "do" "do_pick_failed" "fail" "bash tools/task.sh --pick queue-next" "" "$output"
    print_resume_cmd "$run_id"
    exit "$rc"
  fi
  printf "%s\n" "$output"

  task_file="$(printf "%s\n" "$output" | awk -F': ' '/^TASK_FILE:/ {print $2; exit}')"
  task_run_id="$(printf "%s\n" "$output" | awk -F': ' '/^RUN_ID:/ {print $2; exit}')"
  evidence_path="$(printf "%s\n" "$output" | awk -F': ' '/^EVIDENCE_PATH:/ {print $2; exit}')"
  if [[ -n "$task_file" ]]; then
    echo "TASK_FILE: $task_file"
  fi
  if [[ -n "$task_run_id" ]]; then
    echo "RUN_ID: $task_run_id"
  fi
  if [[ -n "$evidence_path" ]]; then
    echo "EVIDENCE_PATH: $evidence_path"
  fi
  if [[ -n "$task_run_id" ]]; then
    append_execution_event "$task_run_id" "do" "do_pick_success" "ok" "bash tools/task.sh --pick queue-next" "task_file=${task_file};evidence=${evidence_path}" ""
    update_state_current "$task_run_id" "$task_file" "active"
  else
    append_execution_event "$run_id" "do" "do_pick_success" "ok" "bash tools/task.sh --pick queue-next" "task_file=${task_file};evidence=${evidence_path}" ""
    update_state_current "$run_id" "$task_file" "active"
  fi
}

is_qf_stash_cleanup_candidate() {
  local subject="${1:-}"
  case "$subject" in
    *": ship-wip-"*|*": qf-init-wip-"*|*": resume-cleanup-run-"*|*": tmp-ship-cleanup-"*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

cmd_stash_clean() {
  local mode="${1:-preview}"
  local keep_arg="${2:-}"
  local keep_latest="${QF_STASH_CLEAN_KEEP_LATEST:-2}"
  local run_id=""
  local ref=""
  local subject=""
  local total=0
  local drop_count=0
  local i=0
  local action=""
  local command_line=""
  local -a refs=()
  local -a subjects=()

  if [[ "$mode" != "preview" && "$mode" != "apply" ]]; then
    if [[ "$mode" =~ ^KEEP=[0-9]+$ ]]; then
      keep_arg="$mode"
      mode="preview"
    else
      echo "ERROR: stash-clean mode must be preview or apply." >&2
      usage
      exit 2
    fi
  fi

  if [[ -n "$keep_arg" ]]; then
    if [[ "$keep_arg" =~ ^KEEP=([0-9]+)$ ]]; then
      keep_latest="${BASH_REMATCH[1]}"
    else
      echo "ERROR: invalid KEEP argument. expected KEEP=<non-negative-int>." >&2
      exit 2
    fi
  fi

  if [[ ! "$keep_latest" =~ ^[0-9]+$ ]]; then
    echo "ERROR: keep_latest must be a non-negative integer." >&2
    exit 2
  fi

  while IFS='|' read -r ref subject; do
    [[ -z "$ref" ]] && continue
    if is_qf_stash_cleanup_candidate "$subject"; then
      refs+=("$ref")
      subjects+=("$subject")
    fi
  done < <(git stash list --format='%gd|%gs')

  total="${#refs[@]}"
  if (( total == 0 )); then
    echo "stash-clean: no qf/ship cleanup stashes found."
    return 0
  fi

  if (( total > keep_latest )); then
    drop_count=$((total - keep_latest))
  fi

  echo "stash-clean mode=${mode} keep_latest=${keep_latest} candidates=${total} drop=${drop_count}"
  for ((i=0; i<total; i++)); do
    action="keep"
    if (( i >= keep_latest )); then
      action="drop"
    fi
    echo "- [${action}] ${refs[$i]} | ${subjects[$i]}"
  done

  if [[ "$mode" != "apply" ]]; then
    echo "next: tools/qf stash-clean apply KEEP=${keep_latest}"
    return 0
  fi

  if (( drop_count == 0 )); then
    echo "stash-clean: nothing to drop."
    return 0
  fi

  command_line="tools/qf stash-clean apply KEEP=${keep_latest}"
  run_id="$(resolve_state_current_run_id || true)"

  # Drop from oldest to newest to avoid stash index shifting issues.
  for ((i=total-1; i>=keep_latest; i--)); do
    if git stash drop "${refs[$i]}" >/dev/null 2>&1; then
      echo "dropped: ${refs[$i]} | ${subjects[$i]}"
    else
      echo "ERROR: failed to drop ${refs[$i]}" >&2
      if [[ -n "$run_id" ]]; then
        append_execution_event "$run_id" "stash-clean" "stash_clean_failed" "fail" "$command_line" "target=${refs[$i]}" "drop failed"
      fi
      exit 1
    fi
  done

  if [[ -n "$run_id" ]]; then
    append_execution_event "$run_id" "stash-clean" "stash_clean_applied" "ok" "$command_line" "drop_count=${drop_count}" ""
  fi
  echo "stash-clean done: dropped=${drop_count}"
}

cmd_exam_auto_fill_answer() {
  local run_id="$1"
  local answer_file="$2"
  local task_file=""
  local current_status=""
  local stop_reason="tool_or_script_error"
  local latest_subject=""
  local latest_commit=""
  local py_bin=""

  task_file="$(state_field_value "CURRENT_TASK_FILE")"
  current_status="$(state_field_value "CURRENT_STATUS")"
  if [[ -z "$task_file" ]]; then
    task_file="TASKS/TASK-unknown.md"
  fi
  if [[ "$current_status" == "done" ]]; then
    stop_reason="task_done"
  fi
  latest_subject="$(git log -1 --pretty=%s 2>/dev/null || true)"
  latest_commit="$(git rev-parse --short HEAD 2>/dev/null || true)"

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required for tools/qf exam-auto." >&2
    exit 1
  fi

  "$py_bin" - <<'PY' "$run_id" "$answer_file" "$task_file" "$stop_reason" "$latest_subject" "$latest_commit"
from pathlib import Path
import sys

run_id, answer_file, task_file, stop_reason, latest_subject, latest_commit = sys.argv[1:7]
latest_subject = latest_subject.strip()
latest_commit = latest_commit.strip()
if not latest_subject:
    latest_subject = "recent main update"
if not latest_commit:
    latest_commit = "unknown"

text = f"""## 终点一致
自动化、自我迭代、涌现智能是这个仓库的统一北极星。本轮通过把同频考试接入单命令流程，减少人工步骤和会话摩擦，让后续执行可以持续迭代并稳定沉淀证据链。

## 阶段一致
当前阶段是治理与同频自动化强化；下一阶段是基于稳定门禁推进任务执行自动化。阶段切换条件是 ready/exam 通过、证据完整、并且命令链可重复执行。

## 上轮停止原因与恢复状态
上轮停止原因分类是 {stop_reason}。停止时点是 ship/resume 收尾阶段；当前恢复状态是 main 已同步，RUN_ID 对应证据可追溯，可继续执行。

## 边界与非目标
本轮边界是只改治理与流程脚本，不改财富业务策略与量化逻辑；non-goals 是不做策略参数变更，不做外部系统接入，不做无证据的临时修补。

## 近况与最近提交
最近已交付（PR / RUN_ID）可从 TASKS/QUEUE.md Done 记录与 reports 目录核对；当前近况是 exam-auto 自动化增强在推进，最近提交主题为：{latest_subject}（{latest_commit}）。

## 下一步单命令
命令：tools/qf ready RUN_ID={run_id}
为什么是这一条（因果解释）：先完成门禁文件，再进入 plan/do，保证执行有一致入口和可审计前置条件。

## 失败回退命令
命令：tools/qf resume RUN_ID={run_id}
触发条件：ship 或 resume 中断、网络波动或本地同步失败时，使用该命令恢复并完成收尾。

## 学习更新清单
- 本轮必须新增/复习的技能或规则（至少 3 条）：qf 生命周期命令；exam 评分规则；ship/resume 故障恢复。
- 对应学习来源文件：AGENTS.md；docs/WORKFLOW.md；SYNC/EXAM_RUBRIC.json；{task_file}
"""

path = Path(answer_file)
path.parent.mkdir(parents=True, exist_ok=True)
path.write_text(text.rstrip() + "\n", encoding="utf-8")
PY
}

cmd_exam() {
  local explicit_run_id="${RUN_ID:-}"
  local run_id=""
  local answer_file=""
  local rubric_file="${SYNC_EXAM_RUBRIC_FILE:-SYNC/EXAM_RUBRIC.json}"
  local output_file=""
  local py_bin=""
  local arg=""
  local output=""
  local rc=0
  local status="ok"
  local cmd_text=""

  for arg in "$@"; do
    case "$arg" in
      RUN_ID=*)
        explicit_run_id="${arg#RUN_ID=}"
        ;;
      ANSWER_FILE=*)
        answer_file="${arg#ANSWER_FILE=}"
        ;;
      RUBRIC_FILE=*)
        rubric_file="${arg#RUBRIC_FILE=}"
        ;;
      OUTPUT_FILE=*)
        output_file="${arg#OUTPUT_FILE=}"
        ;;
      *)
        if [[ -z "$answer_file" ]]; then
          answer_file="$arg"
        else
          echo "ERROR: unexpected arg for exam: $arg" >&2
          usage
          exit 2
        fi
        ;;
    esac
  done

  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "exam")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: exam requires RUN_ID (explicit or TASKS/STATE.md CURRENT_RUN_ID)." >&2
    exit 2
  fi

  if [[ -z "$answer_file" ]]; then
    answer_file="reports/${run_id}/onboard_answer.md"
  fi
  if [[ -z "$output_file" ]]; then
    output_file="reports/${run_id}/sync_exam_result.json"
  fi

  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required for tools/qf exam." >&2
    exit 1
  fi

  if [[ ! -f "$answer_file" ]]; then
    append_execution_event "$run_id" "exam" "exam_missing_answer" "fail" "tools/qf exam RUN_ID=${run_id}" "answer_file=${answer_file}" "missing answer file"
    echo "ERROR: answer file not found: $answer_file" >&2
    exit 1
  fi

  mkdir -p "reports/${run_id}"
  cmd_text="tools/sync_exam.py --answer-file ${answer_file} --rubric-file ${rubric_file} --output-file ${output_file} --run-id ${run_id}"
  set +e
  output="$("$py_bin" tools/sync_exam.py \
    --answer-file "$answer_file" \
    --rubric-file "$rubric_file" \
    --output-file "$output_file" \
    --run-id "$run_id" 2>&1)"
  rc=$?
  set -e
  printf "%s\n" "$output"

  if [[ "$rc" -ne 0 ]]; then
    status="fail"
  fi
  append_execution_event "$run_id" "exam" "exam_graded" "$status" "tools/qf exam RUN_ID=${run_id}" "answer=${answer_file};rubric=${rubric_file};output=${output_file}" "$output"
  if [[ "$rc" -ne 0 ]]; then
    exit "$rc"
  fi
}

cmd_exam_auto() {
  local explicit_run_id="${RUN_ID:-}"
  local run_id=""
  local answer_file=""
  local rubric_file="${SYNC_EXAM_RUBRIC_FILE:-SYNC/EXAM_RUBRIC.json}"
  local output_file=""
  local template_file="${SYNC_EXAM_TEMPLATE_FILE:-SYNC/EXAM_ANSWER_TEMPLATE.md}"
  local auto_fill="${QF_EXAM_AUTO_FILL:-1}"
  local arg=""
  local command_line=""

  for arg in "$@"; do
    case "$arg" in
      RUN_ID=*)
        explicit_run_id="${arg#RUN_ID=}"
        ;;
      ANSWER_FILE=*)
        answer_file="${arg#ANSWER_FILE=}"
        ;;
      RUBRIC_FILE=*)
        rubric_file="${arg#RUBRIC_FILE=}"
        ;;
      OUTPUT_FILE=*)
        output_file="${arg#OUTPUT_FILE=}"
        ;;
      AUTO_FILL=*)
        auto_fill="${arg#AUTO_FILL=}"
        ;;
      *)
        if [[ -z "$answer_file" ]]; then
          answer_file="$arg"
        else
          echo "ERROR: unexpected arg for exam-auto: $arg" >&2
          usage
          exit 2
        fi
        ;;
    esac
  done

  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "exam-auto")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: exam-auto requires RUN_ID (explicit or TASKS/STATE.md CURRENT_RUN_ID)." >&2
    exit 2
  fi

  if [[ -z "$answer_file" ]]; then
    answer_file="reports/${run_id}/onboard_answer.md"
  fi
  if [[ -z "$output_file" ]]; then
    output_file="reports/${run_id}/sync_exam_result.json"
  fi

  case "${auto_fill,,}" in
    1|true|yes|y)
      auto_fill="1"
      ;;
    0|false|no|n)
      auto_fill="0"
      ;;
    *)
      echo "ERROR: invalid AUTO_FILL value: $auto_fill (expected 0|1)." >&2
      exit 2
      ;;
  esac

  mkdir -p "reports/${run_id}"
  if [[ ! -f "$answer_file" ]]; then
    command_line="tools/qf exam-auto RUN_ID=${run_id}"
    if [[ "$auto_fill" == "0" ]]; then
      if [[ ! -f "$template_file" ]]; then
        append_execution_event "$run_id" "exam-auto" "exam_auto_missing_template" "fail" "$command_line" "template_file=${template_file}" "missing template file"
        echo "ERROR: exam template file not found: $template_file" >&2
        exit 1
      fi
      cp "$template_file" "$answer_file"
      append_execution_event "$run_id" "exam-auto" "exam_auto_answer_scaffolded" "ok" "$command_line" "answer_file=${answer_file}" ""
      echo "EXAM_ANSWER_SCAFFOLDED: $answer_file"
      echo "请先按模板补全答案，再运行：tools/qf exam-auto RUN_ID=${run_id}"
      return 3
    fi

    cmd_exam_auto_fill_answer "$run_id" "$answer_file"
    append_execution_event "$run_id" "exam-auto" "exam_auto_answer_autofilled" "ok" "$command_line" "answer_file=${answer_file}" ""
    echo "EXAM_ANSWER_AUTOFILLED: $answer_file"
  fi

  cmd_exam "RUN_ID=${run_id}" "ANSWER_FILE=${answer_file}" "RUBRIC_FILE=${rubric_file}" "OUTPUT_FILE=${output_file}"
  command_line="tools/qf exam-auto RUN_ID=${run_id}"
  append_execution_event "$run_id" "exam-auto" "exam_auto_done" "ok" "$command_line" "answer_file=${answer_file};output_file=${output_file}" ""
}

read_state_field() {
  local file="$1"
  local key="$2"
  local py_bin=""
  if command -v python3 >/dev/null 2>&1; then
    py_bin="python3"
  elif command -v python >/dev/null 2>&1; then
    py_bin="python"
  else
    echo "ERROR: python is required for parsing ship_state.json" >&2
    exit 1
  fi
  "$py_bin" - <<'PY' "$file" "$key"
import json
import sys
path, key = sys.argv[1], sys.argv[2]
with open(path, "r", encoding="utf-8") as f:
    obj = json.load(f)
val = obj.get(key, "")
if val is None:
    val = ""
print(str(val))
PY
}

cmd_resume() {
  local arg="${1:-}"
  local run_id=""
  local explicit_run_id=""
  local state_file=""
  local step=""
  local branch=""
  local pr_url=""
  local merged_pr_url=""
  local skip_ship_steps=0
  local msg=""
  local pr_body=""
  local state=""

  if [[ "$arg" =~ ^RUN_ID=.+$ ]]; then
    explicit_run_id="${arg#RUN_ID=}"
  elif [[ -n "$arg" ]]; then
    explicit_run_id="$arg"
  elif [[ -n "${RUN_ID:-}" ]]; then
    explicit_run_id="${RUN_ID}"
  fi
  run_id="$(resolve_run_id_for_cmd "$explicit_run_id" "resume")"
  if [[ -z "$run_id" ]]; then
    echo "ERROR: resume requires RUN_ID (explicit or TASKS/STATE.md CURRENT_RUN_ID)."
    usage
    exit 2
  fi

  state_file="reports/${run_id}/ship_state.json"
  if [[ ! -f "$state_file" ]]; then
    append_execution_event "$run_id" "resume" "resume_missing_state" "fail" "tools/qf resume RUN_ID=${run_id}" "state_file=${state_file}" "missing state file"
    echo "ERROR: missing state file: $state_file"
    print_resume_cmd "$run_id"
    exit 1
  fi

  append_execution_event "$run_id" "resume" "resume_start" "ok" "tools/qf resume RUN_ID=${run_id}" "state_file=${state_file}" ""

  step="$(read_state_field "$state_file" "step")"
  branch="$(read_state_field "$state_file" "branch")"
  pr_url="$(read_state_field "$state_file" "pr_url")"
  msg="$(read_state_field "$state_file" "msg")"
  if [[ -z "$msg" ]]; then
    msg="${run_id}: resume ship"
  fi

  echo "resume state: step=${step:-unknown} branch=${branch:-unknown} pr_url=${pr_url:-none}"
  if [[ -z "$branch" ]]; then
    echo "ERROR: ship_state.json has empty branch."
    print_resume_cmd "$run_id"
    exit 1
  fi

  run_with_retry_capture "resume_fetch" git fetch origin || {
    append_execution_event "$run_id" "resume" "resume_fetch_failed" "fail" "git fetch origin" "" "${RETRY_LAST_ERROR:-fetch failed}"
    print_resume_cmd "$run_id"
    exit 1
  }

  if [[ -n "$pr_url" && "$pr_url" != "null" ]]; then
    run_with_retry_capture "resume_pr_state_precheck" gh pr view "$pr_url" --json state -q .state || true
    state="$(printf "%s\n" "$RETRY_OUTPUT" | tail -n1 | tr -d '\r')"
    if [[ "$state" == "MERGED" ]]; then
      skip_ship_steps=1
      append_execution_event "$run_id" "resume" "resume_pr_already_merged" "ok" "gh pr view $pr_url --json state -q .state" "pr_url=${pr_url}" ""
      echo "resume: detected merged PR, skip push/create/merge: $pr_url"
    fi
  fi

  if [[ "$skip_ship_steps" -eq 0 && ( -z "$pr_url" || "$pr_url" == "null" ) ]]; then
    run_with_retry_capture "resume_pr_lookup_merged" gh pr list --head "$branch" --base main --state merged --limit 1 --json url -q '.[0].url' || true
    merged_pr_url="$(printf "%s\n" "$RETRY_OUTPUT" | awk '/^https:\/\/github\.com\/.*\/pull\/[0-9]+$/ {print; exit}')"
    if [[ -n "$merged_pr_url" ]]; then
      pr_url="$merged_pr_url"
      skip_ship_steps=1
      append_execution_event "$run_id" "resume" "resume_pr_already_merged" "ok" "gh pr list --head $branch --base main --state merged" "pr_url=${pr_url}" ""
      echo "resume: found merged PR by head branch, skip push/create/merge: $pr_url"
    fi
  fi

  if [[ "$skip_ship_steps" -eq 0 ]]; then
    if git show-ref --verify --quiet "refs/heads/${branch}"; then
      run_with_retry_capture "resume_checkout_branch" git checkout "$branch" || {
        append_execution_event "$run_id" "resume" "resume_checkout_failed" "fail" "git checkout $branch" "" "${RETRY_LAST_ERROR:-checkout failed}"
        print_resume_cmd "$run_id"
        exit 1
      }
    else
      run_with_retry_capture "resume_checkout_branch" git checkout -b "$branch" "origin/$branch" || {
        append_execution_event "$run_id" "resume" "resume_checkout_failed" "fail" "git checkout -b $branch origin/$branch" "" "${RETRY_LAST_ERROR:-checkout failed}"
        print_resume_cmd "$run_id"
        exit 1
      }
    fi

    run_with_retry_capture "resume_push" git push -u origin "$branch" || {
      append_execution_event "$run_id" "resume" "resume_push_failed" "fail" "git push -u origin $branch" "" "${RETRY_LAST_ERROR:-push failed}"
      print_resume_cmd "$run_id"
      exit 1
    }

    if [[ -z "$pr_url" || "$pr_url" == "null" ]]; then
      pr_body="Resume ship for ${run_id}."
      if [[ -f "reports/${run_id}/pr_body_excerpt.md" ]]; then
        pr_body="$(cat "reports/${run_id}/pr_body_excerpt.md")"
      fi
      run_with_retry_capture "resume_pr_create" gh pr create --base main --head "$branch" --title "$msg" --body "$pr_body" || {
        append_execution_event "$run_id" "resume" "resume_pr_create_failed" "fail" "gh pr create --base main --head $branch" "" "${RETRY_LAST_ERROR:-pr create failed}"
        print_resume_cmd "$run_id"
        exit 1
      }
      pr_url="$(printf "%s\n" "$RETRY_OUTPUT" | awk '/^https:\/\/github\.com\/.*\/pull\/[0-9]+$/ {print; exit}')"
      if [[ -z "$pr_url" ]]; then
        echo "ERROR: failed to parse PR url from gh output."
        print_resume_cmd "$run_id"
        exit 1
      fi
      echo "PR: $pr_url"
    fi

    run_with_retry_capture "resume_pr_merge_auto" gh pr merge --auto --squash --delete-branch "$pr_url" || true
    run_with_retry_capture "resume_pr_state" gh pr view "$pr_url" --json state -q .state || {
      append_execution_event "$run_id" "resume" "resume_pr_state_failed" "fail" "gh pr view $pr_url --json state -q .state" "" "${RETRY_LAST_ERROR:-pr state failed}"
      print_resume_cmd "$run_id"
      exit 1
    }
    state="$(printf "%s\n" "$RETRY_OUTPUT" | tail -n1 | tr -d '\r')"
    if [[ "$state" != "MERGED" ]]; then
      run_with_retry_capture "resume_pr_merge" gh pr merge --squash --delete-branch "$pr_url" || {
        append_execution_event "$run_id" "resume" "resume_pr_merge_failed" "fail" "gh pr merge --squash --delete-branch $pr_url" "" "${RETRY_LAST_ERROR:-pr merge failed}"
        print_resume_cmd "$run_id"
        exit 1
      }
    fi
  fi

  run_with_retry_capture "resume_sync_checkout_main" git checkout main || {
    append_execution_event "$run_id" "resume" "resume_sync_checkout_failed" "fail" "git checkout main" "" "${RETRY_LAST_ERROR:-checkout main failed}"
    print_resume_cmd "$run_id"
    exit 1
  }
  run_with_retry_capture "resume_sync_pull_main" git pull --rebase origin main || {
    append_execution_event "$run_id" "resume" "resume_sync_pull_failed" "fail" "git pull --rebase origin main" "" "${RETRY_LAST_ERROR:-sync pull failed}"
    print_resume_cmd "$run_id"
    exit 1
  }
  append_execution_event "$run_id" "resume" "resume_done" "ok" "tools/qf resume RUN_ID=${run_id}" "pr_url=${pr_url}" ""
  update_state_current "$run_id" "$(state_field_value "CURRENT_TASK_FILE")" "done"
  echo "resume done: ${run_id}"
}

subcmd="${1:-}"
case "$subcmd" in
  init)
    shift
    cmd_init "$@"
    ;;
  onboard)
    shift
    cmd_onboard "${1:-}"
    ;;
  ready)
    shift
    cmd_ready "${1:-}"
    ;;
  snapshot)
    shift
    cmd_snapshot "$@"
    ;;
  handoff)
    shift
    cmd_handoff "${1:-}"
    ;;
  exam)
    shift
    cmd_exam "$@"
    ;;
  exam-auto)
    shift
    cmd_exam_auto "$@"
    ;;
  plan)
    shift
    cmd_plan "${1:-20}"
    ;;
  do)
    shift
    cmd_do "${1:-}"
    ;;
  stash-clean)
    shift
    cmd_stash_clean "${1:-preview}" "${2:-}"
    ;;
  resume)
    shift
    cmd_resume "${1:-}"
    ;;
  *)
    usage
    exit 2
    ;;
esac
